{"version":3,"sources":["webpack://nulogy.design/./node_modules/@miksu/prettier/lib/language-js/printer-estree.js"],"names":["_toConsumableArray","arr","Array","isArray","_arrayLikeToArray","_arrayWithoutHoles","iter","Symbol","iterator","Object","from","_iterableToArray","o","minLen","n","prototype","toString","call","slice","constructor","name","test","_unsupportedIterableToArray","TypeError","_nonIterableSpread","len","length","i","arr2","_typeof","obj","assert","comments","_require","getParentExportDeclaration","isExportDeclaration","shouldFlatten","getNextNonSpaceNonCommentCharacter","hasNewline","hasNewlineInRange","getLast","getStringWidth","printString","printNumber","hasIgnoreComment","skipWhitespace","hasNodeIgnoreComment","getPenultimate","startsWithNoLookaheadToken","getIndentSize","matchAncestorTypes","getPreferredQuote","_require2","isNextLineEmpty","isNextLineEmptyAfterIndex","getNextNonSpaceNonCommentCharacterIndex","isIdentifierName","embed","clean","insertPragma","handleComments","pathNeedsParens","_require3","printHtmlBinding","isVueEventBindingExpression","preprocess","_require4","getLeftSide","getLeftSidePathName","hasNakedLeftSide","hasNode","hasFlowAnnotationComment","hasFlowShorthandAnnotationComment","needsQuoteProps","WeakMap","_require5","_require5$builders","builders","concat","join","line","hardline","softline","literalline","group","indent","align","conditionalGroup","fill","ifBreak","breakParent","lineSuffixBoundary","addAlignmentToDoc","dedent","_require5$utils","utils","willBreak","isLineNext","isEmpty","removeLines","printDocToString","printer","uid","shouldPrintComma","options","level","trailingComma","hasNewlineBetweenOrAfterDecorators","node","originalText","locStart","decorators","locEnd","printDecorators","path","print","getValue","map","printTernaryOperator","operatorOptions","currentParent","previousParent","testNode","testNodePropertyName","consequentNode","consequentNodePropertyName","alternateNode","alternateNodePropertyName","parts","jsxMode","parent","getParentNode","forceNoIndent","type","conditionalNodeType","firstNonConditionalParent","lastConditionalParent","shouldCheckJsx","isJSXNode","Boolean","nonConditionalExpressions","recurse","consequent","alternate","push","getConditionalChainContents","find","conditionalExpressionChainContainsJSX","wrap","doc","isNull","value","part","useTabs","Math","max","tabWidth","testDoc","breakClosingParen","computed","beforeParts","afterParts","breakNested","getTypeScriptMappedTypeModifier","tokenNode","keyword","isNgForOf","index","parentNode","key","body","printStatementSequence","printed","bodyNode","getNode","isClass","stmtPath","stmt","stmtPrinted","text","semi","isTheOnlyJSXElementInMarkdown","childPath","exprNeedsASIProtection","stmtNeedsASIProtection","some","comment","leading","needsSemi","typeAnnotation","classPropMayCauseASIProblems","accessibility","isAsync","async","isGenerator","generator","kind","classChildNeedsASIProtection","filter","isLastStatement","printPropertyKey","quoteProps","has","objectHasStringProp","properties","members","prop","isStringLiteral","isStringPropSafeToCoerceToIdentifier","set","parser","get","JSON","stringify","keyPath","printComments","printMethod","ok","valuePath","printFunctionTypeParameters","printFunctionParams","printReturnType","couldGroupArg","arg","elements","returnType","isSimpleFlowType","indexOf","typeParameters","functionCompositionFunctionNames","Set","ordinaryMethodNames","isFunctionCompositionFunction","property","printArgumentsList","args","arguments","printDanglingComments","params","anyArgEmptyLine","hasEmptyLineFollowingFirstArg","lastArgIndex","printedArguments","argPath","param","hasEmptyLineInObjectArgInArrowFunction","maybeTrailingComma","callee","allArgsBrokenOut","shouldBreak","shouldGroupFirst","firstArg","secondArg","shouldGroupFirstArg","shouldGroupLast","lastArg","penultimateArg","hasLeadingComment","hasTrailingComment","shouldGroupLastArg","printedExpanded","each","p","expandFirstArg","expandLastArg","somePrintedArgumentsWillBreak","simpleConcat","printTypeAnnotation","isDefinite","definite","isFunctionDeclarationIdentifier","id","isFlowAnnotationComment","fun","typeArguments","expandArg","printTypeParams","paramsField","parameters","isParametersInTestCall","isTestCall","shouldHugParameters","shouldHugArguments","shouldExpandParameters","typeParams","rest","lastParam","hasNotParameterDecorator","every","isObjectTypePropertyAFunction","sameLocStart","isTypeAnnotationAFunction","arrowParens","canHaveTrailingComma","shouldPrintParamsWithoutParens","hasDanglingComments","optional","predicate","canPrintParamsWithoutParens","printFunctionDeclaration","printObjectMethod","objMethod","method","unshift","printExportDeclaration","decl","isDefault","needsHardlineAfterDanglingComment","declaration","specifiers","defaultSpecifiers","namespaceSpecifiers","specifierPath","specifierType","isNamespaceFollowed","isDefaultFollowed","canBreak","bracketSpacing","exportKind","source","printFlowDeclaration","parentExportDecl","strictEqual","getFlowVariance","variance","printTypeScriptModifiers","modifiers","printTypeParameters","paramsKey","grandparent","shouldHugType","typeName","printClass","partsGroup","superClass","hasLeadingOwnLineComment","printOptionalToken","printMemberLookup","isNumericLiteral","printBindExpressionCallee","isCallOrOptionalCallExpression","containsNonJsxWhitespaceRegex","RegExp","matchJsxWhitespaceRegex","isMeaningfulJSXText","isLiteral","rawText","separatorNoWhitespace","isFacebookTranslationTag","child","childNode","nextNode","closingElement","separatorWithWhitespace","isBinaryish","isMemberish","object","shouldInlineLogicalExpression","right","printBinaryishExpressions","isNested","isInsideParenthesis","operator","left","shouldInline","lineBeforeOperator","rightSuffix","shouldGroup","printAssignmentRight","leftNode","rightNode","printedRight","isMemberExpressionChain","printAssignment","printedLeft","adjustClause","clause","forceSpace","nodeStr","isFlowOrTypeScriptDirectiveLiteral","raw","isDirectiveLiteral","printRegex","flags","split","sort","pattern","trailing","start","end","substr","prefix","regex","apply","isFunctionNotation","isGetterOrSetter","nodeA","nodeB","isNodeStartingWithDeclare","match","range","startsWith","isObjectType","voidCount","types","objectCount","templateLiteralHasNewLines","template","quasis","quasi","includes","isTemplateOnItsOwnLine","backwards","printArrayItems","printPath","printedElements","separatorParts","lastDanglingComment","isBlockComment","unitTestRe","isAngularTestWrapper","isFunctionOrArrowExpression","unitTestSetUpRe","isUnitTestSetUp","isTemplateLiteral","isFunctionOrArrowExpressionWithBody","parentParser","expression","identity","x","module","exports","needsParens","linesWithoutParens","htmlBinding","program","interpreter","programPath","directives","bodyPath","directive","_parent","parentParent","_parts","shouldNotIndent","shouldIndentIfInlining","samePrecedenceSubExpression","hasJSX","groupId","chain","jsxPart","shouldBreakAfterCast","castGroup","exprContents","firstNonMemberParent","_parent2","dangling","nextCharacter","shouldAddSoftLine","printTrailingComma","shouldAddParens","delegate","argument","importKind","local","imported","exported","standalones","grouped","naked","hasContent","hasDirectives","_parent3","_parentParent","finalizer","newLeftMost","leftMost","returnArgumentHasLeadingComment","isNew","isIdentifierWithFlowAnnotation","trailingComments","printedNodes","shouldInsertEmptyLineAfter","nextCharIndex","charAt","rec","groups","currentGroup","hasSeenCallExpression","isFactory","isShort","shouldNotWrap","isExpression","hasComputed","firstNode","lastNode","shouldMerge","printGroup","printedGroup","tuple","printIndentedGroup","printedGroups","oneLine","cutoff","flatGroups","reduce","res","hasComment","lastNodeBeforeIndent","shouldHaveEmptyLineBeforeIndent","expanded","callExpressions","_ref","lastGroupDoc","lastGroupNode","printMemberChain","substring","trim","propertiesField","isTypeAnnotation","fields","firstProperty","field","a","b","_parent4","isFlowInterfaceLikeBody","getName","separator","leftBrace","exact","rightBrace","propsAndLoc","forEach","loc","props","result","shift","inexact","content","lastElem","canHaveTrailingSeparator","parentParentParent","shorthand","_lastElem","needsForcedTrailingComma","_parent5","_parts2","extra","rawValue","grandParent","isTypeScriptDirective","reverse","firstVariable","isParentForLoop","hasValue","declarations","init","declare","_printed","con","opening","commentOnOwnLine","elseOnSameLine","_body","_dangling","printedComments","update","isAwait","doBody","label","handler","hasComments","cases","casePath","caseNode","cons","consequentPath","_final","replace","quote","jsxSingleQuote","_escape","_parent6","_shouldInline","elem","children","isEmptyJSXElement","openingLines","closingLines","isJSXWhitespaceExpression","containsTag","containsMultipleExpressions","containsMultipleAttributes","openingElement","attributes","forcedBreak","rawJsxWhitespace","singleQuote","jsxWhitespace","endWhitespace","words","next","pop","word","undefined","_next","_next2","printedChild","_next3","firstWord","printJSXChildren","containsText","isPairOfEmptyStrings","isPairOfHardlines","isLineFollowedByJSXWhitespace","isJSXWhitespaceFollowedByLine","isDoubleJSXWhitespace","isPairOfHardOrSoftLines","splice","multilineChildren","multiLineElem","printJSXElement","ArrayExpression","JSXAttribute","JSXElement","JSXExpressionContainer","JSXFragment","ExpressionStatement","CallExpression","OptionalCallExpression","ConditionalExpression","JsExpressionRoot","maybeWrapJSXElementInParens","_n","nameHasComments","selfClosing","lastAttrHasTrailingComments","bracketSameLine","jsxBracketSameLine","_shouldBreak","attr","hasOwnLineComment","isOpeningFragment","Error","requiresHardline","readonly","expressions","_parentNode","jestEachTriggerRegex","tag","isJestEachTemplateLiteral","_printed2","headerNames","headerName","stringifiedExpressions","assign","printWidth","Infinity","endOfLine","formatted","tableBody","hasLineBreak","cells","row","correspondingExpression","maxColumnCount","maxColumnWidths","table","cell","repeat","printJestEachTemplateLiteral","isSimple","expr","ancestor","isSimpleTemplateLiteral","indentSize","_printed3","aligned","endsWith","typesField","supertype","impltype","_parent7","_parentParent2","_parentParentParent","isArrowFunctionTypeAnnotation","needsColon","wasIndented","_i","_parent8","shouldIndent","shouldHug","_printed4","typePath","printedType","hasParens","shouldAddStartLine","code","_grandParent","greatGrandParent","greatGreatGrandParent","_variance","_variance2","modifier","proto","_printed5","commentSyntax","_value","commentStart","lastIndexOf","_parent9","constraint","_variance3","bound","_grandParent2","filepath","initializer","_parent10","isTypeOf","qualifier","isType","_shouldBreak2","isExport","_parent11","isExternalModule","parentIsDeclaration","bodyIsDeclaration","textBetweenNodeAndItsId","trimRight","hasNgSideEffect","alias","_parentNode2","shouldNotPrintColon","printPathNoParens","ignoreDecorators","decoratorPath","decorator","_node","trimLeft","massageAstNode","hasPrettierIgnore","prevSibling","candidate","hasJsxIgnoreComment","willPrintOwnComments","leadingComments","canAttachComment","printComment","commentPath","lines","isIndentableBlockComment","printIndentableBlockComment","isInsideFlowComment","ownLine","handleOwnLineComment","handleEndOfLineComment","remaining","handleRemainingComment"],"mappings":"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","file":"8fa5cb00-880e2ce48aeb81fe7a21.js","sourcesContent":["\"use strict\";\n\nrequire(\"core-js/modules/es.string.trim-end.js\");\n\nrequire(\"core-js/modules/es.string.trim-start.js\");\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar assert = require(\"assert\"); // TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.\n\n\nvar comments = require(\"../main/comments\");\n\nvar _require = require(\"../common/util\"),\n    getParentExportDeclaration = _require.getParentExportDeclaration,\n    isExportDeclaration = _require.isExportDeclaration,\n    shouldFlatten = _require.shouldFlatten,\n    getNextNonSpaceNonCommentCharacter = _require.getNextNonSpaceNonCommentCharacter,\n    hasNewline = _require.hasNewline,\n    hasNewlineInRange = _require.hasNewlineInRange,\n    getLast = _require.getLast,\n    getStringWidth = _require.getStringWidth,\n    printString = _require.printString,\n    printNumber = _require.printNumber,\n    hasIgnoreComment = _require.hasIgnoreComment,\n    skipWhitespace = _require.skipWhitespace,\n    hasNodeIgnoreComment = _require.hasNodeIgnoreComment,\n    getPenultimate = _require.getPenultimate,\n    startsWithNoLookaheadToken = _require.startsWithNoLookaheadToken,\n    getIndentSize = _require.getIndentSize,\n    matchAncestorTypes = _require.matchAncestorTypes,\n    getPreferredQuote = _require.getPreferredQuote;\n\nvar _require2 = require(\"../common/util-shared\"),\n    isNextLineEmpty = _require2.isNextLineEmpty,\n    isNextLineEmptyAfterIndex = _require2.isNextLineEmptyAfterIndex,\n    getNextNonSpaceNonCommentCharacterIndex = _require2.getNextNonSpaceNonCommentCharacterIndex;\n\nvar isIdentifierName = require(\"esutils\").keyword.isIdentifierNameES5;\n\nvar embed = require(\"./embed\");\n\nvar clean = require(\"./clean\");\n\nvar insertPragma = require(\"./pragma\").insertPragma;\n\nvar handleComments = require(\"./comments\");\n\nvar pathNeedsParens = require(\"./needs-parens\");\n\nvar _require3 = require(\"./html-binding\"),\n    printHtmlBinding = _require3.printHtmlBinding,\n    isVueEventBindingExpression = _require3.isVueEventBindingExpression;\n\nvar preprocess = require(\"./preprocess\");\n\nvar _require4 = require(\"./utils\"),\n    getLeftSide = _require4.getLeftSide,\n    getLeftSidePathName = _require4.getLeftSidePathName,\n    hasNakedLeftSide = _require4.hasNakedLeftSide,\n    hasNode = _require4.hasNode,\n    hasFlowAnnotationComment = _require4.hasFlowAnnotationComment,\n    hasFlowShorthandAnnotationComment = _require4.hasFlowShorthandAnnotationComment;\n\nvar needsQuoteProps = new WeakMap();\n\nvar _require5 = require(\"../doc\"),\n    _require5$builders = _require5.builders,\n    concat = _require5$builders.concat,\n    join = _require5$builders.join,\n    line = _require5$builders.line,\n    hardline = _require5$builders.hardline,\n    softline = _require5$builders.softline,\n    literalline = _require5$builders.literalline,\n    group = _require5$builders.group,\n    indent = _require5$builders.indent,\n    align = _require5$builders.align,\n    conditionalGroup = _require5$builders.conditionalGroup,\n    fill = _require5$builders.fill,\n    ifBreak = _require5$builders.ifBreak,\n    breakParent = _require5$builders.breakParent,\n    lineSuffixBoundary = _require5$builders.lineSuffixBoundary,\n    addAlignmentToDoc = _require5$builders.addAlignmentToDoc,\n    dedent = _require5$builders.dedent,\n    _require5$utils = _require5.utils,\n    willBreak = _require5$utils.willBreak,\n    isLineNext = _require5$utils.isLineNext,\n    isEmpty = _require5$utils.isEmpty,\n    removeLines = _require5$utils.removeLines,\n    printDocToString = _require5.printer.printDocToString;\n\nvar uid = 0;\n\nfunction shouldPrintComma(options, level) {\n  level = level || \"es5\";\n\n  switch (options.trailingComma) {\n    case \"all\":\n      if (level === \"all\") {\n        return true;\n      }\n\n    // fallthrough\n\n    case \"es5\":\n      if (level === \"es5\") {\n        return true;\n      }\n\n    // fallthrough\n\n    case \"none\":\n    default:\n      return false;\n  }\n}\n\nfunction genericPrint(path, options, printPath, args) {\n  var node = path.getValue();\n  var needsParens = false;\n  var linesWithoutParens = printPathNoParens(path, options, printPath, args);\n\n  if (!node || isEmpty(linesWithoutParens)) {\n    return linesWithoutParens;\n  }\n\n  var parentExportDecl = getParentExportDeclaration(path);\n  var decorators = [];\n\n  if (node.type === \"ClassMethod\" || node.type === \"ClassPrivateMethod\" || node.type === \"ClassProperty\" || node.type === \"TSAbstractClassProperty\" || node.type === \"ClassPrivateProperty\" || node.type === \"MethodDefinition\" || node.type === \"TSAbstractMethodDefinition\") {// their decorators are handled themselves\n  } else if (node.decorators && node.decorators.length > 0 && // If the parent node is an export declaration and the decorator\n  // was written before the export, the export will be responsible\n  // for printing the decorators.\n  !(parentExportDecl && options.locStart(parentExportDecl, {\n    ignoreDecorators: true\n  }) > options.locStart(node.decorators[0]))) {\n    var shouldBreak = node.type === \"ClassExpression\" || node.type === \"ClassDeclaration\" || hasNewlineBetweenOrAfterDecorators(node, options);\n    var separator = shouldBreak ? hardline : line;\n    path.each(function (decoratorPath) {\n      var decorator = decoratorPath.getValue();\n\n      if (decorator.expression) {\n        decorator = decorator.expression;\n      } else {\n        decorator = decorator.callee;\n      }\n\n      decorators.push(printPath(decoratorPath), separator);\n    }, \"decorators\");\n\n    if (parentExportDecl) {\n      decorators.unshift(hardline);\n    }\n  } else if (isExportDeclaration(node) && node.declaration && node.declaration.decorators && node.declaration.decorators.length > 0 && // Only print decorators here if they were written before the export,\n  // otherwise they are printed by the node.declaration\n  options.locStart(node, {\n    ignoreDecorators: true\n  }) > options.locStart(node.declaration.decorators[0])) {\n    // Export declarations are responsible for printing any decorators\n    // that logically apply to node.declaration.\n    path.each(function (decoratorPath) {\n      var decorator = decoratorPath.getValue();\n      var prefix = decorator.type === \"Decorator\" ? \"\" : \"@\";\n      decorators.push(prefix, printPath(decoratorPath), hardline);\n    }, \"declaration\", \"decorators\");\n  } else {\n    // Nodes with decorators can't have parentheses, so we can avoid\n    // computing pathNeedsParens() except in this case.\n    needsParens = pathNeedsParens(path, options);\n  }\n\n  var parts = [];\n\n  if (needsParens) {\n    parts.unshift(\"(\");\n  }\n\n  parts.push(linesWithoutParens);\n\n  if (needsParens) {\n    var _node = path.getValue();\n\n    if (hasFlowShorthandAnnotationComment(_node)) {\n      parts.push(\" /*\");\n      parts.push(_node.trailingComments[0].value.trimLeft());\n      parts.push(\"*/\");\n      _node.trailingComments[0].printed = true;\n    }\n\n    parts.push(\")\");\n  }\n\n  if (decorators.length > 0) {\n    return group(concat(decorators.concat(parts)));\n  }\n\n  return concat(parts);\n}\n\nfunction hasNewlineBetweenOrAfterDecorators(node, options) {\n  return hasNewlineInRange(options.originalText, options.locStart(node.decorators[0]), options.locEnd(getLast(node.decorators))) || hasNewline(options.originalText, options.locEnd(getLast(node.decorators)));\n}\n\nfunction printDecorators(path, options, print) {\n  var node = path.getValue();\n  return group(concat([join(line, path.map(print, \"decorators\")), hasNewlineBetweenOrAfterDecorators(node, options) ? hardline : line]));\n}\n\nfunction hasPrettierIgnore(path) {\n  return hasIgnoreComment(path) || hasJsxIgnoreComment(path);\n}\n\nfunction hasJsxIgnoreComment(path) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n\n  if (!parent || !node || !isJSXNode(node) || !isJSXNode(parent)) {\n    return false;\n  } // Lookup the previous sibling, ignoring any empty JSXText elements\n\n\n  var index = parent.children.indexOf(node);\n  var prevSibling = null;\n\n  for (var i = index; i > 0; i--) {\n    var candidate = parent.children[i - 1];\n\n    if (candidate.type === \"JSXText\" && !isMeaningfulJSXText(candidate)) {\n      continue;\n    }\n\n    prevSibling = candidate;\n    break;\n  }\n\n  return prevSibling && prevSibling.type === \"JSXExpressionContainer\" && prevSibling.expression.type === \"JSXEmptyExpression\" && prevSibling.expression.comments && prevSibling.expression.comments.find(function (comment) {\n    return comment.value.trim() === \"prettier-ignore\";\n  });\n}\n/**\n * The following is the shared logic for\n * ternary operators, namely ConditionalExpression\n * and TSConditionalType\n * @typedef {Object} OperatorOptions\n * @property {() => Array<string | Doc>} beforeParts - Parts to print before the `?`.\n * @property {(breakClosingParen: boolean) => Array<string | Doc>} afterParts - Parts to print after the conditional expression.\n * @property {boolean} shouldCheckJsx - Whether to check for and print in JSX mode.\n * @property {string} conditionalNodeType - The type of the conditional expression node, ie \"ConditionalExpression\" or \"TSConditionalType\".\n * @property {string} consequentNodePropertyName - The property at which the consequent node can be found on the main node, eg \"consequent\".\n * @property {string} alternateNodePropertyName - The property at which the alternate node can be found on the main node, eg \"alternate\".\n * @property {string} testNodePropertyName - The property at which the test node can be found on the main node, eg \"test\".\n * @property {boolean} breakNested - Whether to break all nested ternaries when one breaks.\n * @param {FastPath} path - The path to the ConditionalExpression/TSConditionalType node.\n * @param {Options} options - Prettier options\n * @param {Function} print - Print function to call recursively\n * @param {OperatorOptions} operatorOptions\n * @returns Doc\n */\n\n\nfunction printTernaryOperator(path, options, print, operatorOptions) {\n  var node = path.getValue();\n  var testNode = node[operatorOptions.testNodePropertyName];\n  var consequentNode = node[operatorOptions.consequentNodePropertyName];\n  var alternateNode = node[operatorOptions.alternateNodePropertyName];\n  var parts = []; // We print a ConditionalExpression in either \"JSX mode\" or \"normal mode\".\n  // See tests/jsx/conditional-expression.js for more info.\n\n  var jsxMode = false;\n  var parent = path.getParentNode();\n  var forceNoIndent = parent.type === operatorOptions.conditionalNodeType; // Find the outermost non-ConditionalExpression parent, and the outermost\n  // ConditionalExpression parent. We'll use these to determine if we should\n  // print in JSX mode.\n\n  var currentParent;\n  var previousParent;\n  var i = 0;\n\n  do {\n    previousParent = currentParent || node;\n    currentParent = path.getParentNode(i);\n    i++;\n  } while (currentParent && currentParent.type === operatorOptions.conditionalNodeType);\n\n  var firstNonConditionalParent = currentParent || parent;\n  var lastConditionalParent = previousParent;\n\n  if (operatorOptions.shouldCheckJsx && (isJSXNode(testNode) || isJSXNode(consequentNode) || isJSXNode(alternateNode) || conditionalExpressionChainContainsJSX(lastConditionalParent))) {\n    jsxMode = true;\n    forceNoIndent = true; // Even though they don't need parens, we wrap (almost) everything in\n    // parens when using ?: within JSX, because the parens are analogous to\n    // curly braces in an if statement.\n\n    var wrap = function wrap(doc) {\n      return concat([ifBreak(\"(\", \"\"), indent(concat([softline, doc])), softline, ifBreak(\")\", \"\")]);\n    }; // The only things we don't wrap are:\n    // * Nested conditional expressions in alternates\n    // * null\n\n\n    var isNull = function isNull(node) {\n      return node.type === \"NullLiteral\" || node.type === \"Literal\" && node.value === null;\n    };\n\n    parts.push(\" ? \", isNull(consequentNode) ? path.call(print, operatorOptions.consequentNodePropertyName) : wrap(path.call(print, operatorOptions.consequentNodePropertyName)), \" : \", alternateNode.type === operatorOptions.conditionalNodeType || isNull(alternateNode) ? path.call(print, operatorOptions.alternateNodePropertyName) : wrap(path.call(print, operatorOptions.alternateNodePropertyName)));\n  } else {\n    // normal mode\n    var part = concat([line, \"? \", consequentNode.type === operatorOptions.conditionalNodeType ? ifBreak(\"\", \"(\") : \"\", align(2, path.call(print, operatorOptions.consequentNodePropertyName)), consequentNode.type === operatorOptions.conditionalNodeType ? ifBreak(\"\", \")\") : \"\", line, \": \", alternateNode.type === operatorOptions.conditionalNodeType ? path.call(print, operatorOptions.alternateNodePropertyName) : align(2, path.call(print, operatorOptions.alternateNodePropertyName))]);\n    parts.push(parent.type !== operatorOptions.conditionalNodeType || parent[operatorOptions.alternateNodePropertyName] === node ? part : options.useTabs ? dedent(indent(part)) : align(Math.max(0, options.tabWidth - 2), part));\n  } // We want a whole chain of ConditionalExpressions to all\n  // break if any of them break. That means we should only group around the\n  // outer-most ConditionalExpression.\n\n\n  var maybeGroup = function maybeGroup(doc) {\n    return operatorOptions.breakNested ? parent === firstNonConditionalParent ? group(doc) : doc : group(doc);\n  }; // Break the closing paren to keep the chain right after it:\n  // (a\n  //   ? b\n  //   : c\n  // ).call()\n\n\n  var breakClosingParen = !jsxMode && (parent.type === \"MemberExpression\" || parent.type === \"OptionalMemberExpression\") && !parent.computed;\n  return maybeGroup(concat([].concat(function (testDoc) {\n    return (\n      /**\n       *     a\n       *       ? b\n       *       : multiline\n       *         test\n       *         node\n       *       ^^ align(2)\n       *       ? d\n       *       : e\n       */\n      parent.type === operatorOptions.conditionalNodeType && parent[operatorOptions.alternateNodePropertyName] === node ? align(2, testDoc) : testDoc\n    );\n  }(concat(operatorOptions.beforeParts())), forceNoIndent ? concat(parts) : indent(concat(parts)), operatorOptions.afterParts(breakClosingParen))));\n}\n\nfunction getTypeScriptMappedTypeModifier(tokenNode, keyword) {\n  if (tokenNode === \"+\") {\n    return \"+\" + keyword;\n  } else if (tokenNode === \"-\") {\n    return \"-\" + keyword;\n  }\n\n  return keyword;\n}\n\nfunction printPathNoParens(path, options, print, args) {\n  var n = path.getValue();\n  var semi = options.semi ? \";\" : \"\";\n\n  if (!n) {\n    return \"\";\n  }\n\n  if (typeof n === \"string\") {\n    return n;\n  }\n\n  var htmlBinding = printHtmlBinding(path, options, print);\n\n  if (htmlBinding) {\n    return htmlBinding;\n  }\n\n  var parts = [];\n\n  switch (n.type) {\n    case \"JsExpressionRoot\":\n      return path.call(print, \"node\");\n\n    case \"JsonRoot\":\n      return concat([path.call(print, \"node\"), hardline]);\n\n    case \"File\":\n      // Print @babel/parser's InterpreterDirective here so that\n      // leading comments on the `Program` node get printed after the hashbang.\n      if (n.program && n.program.interpreter) {\n        parts.push(path.call(function (programPath) {\n          return programPath.call(print, \"interpreter\");\n        }, \"program\"));\n      }\n\n      parts.push(path.call(print, \"program\"));\n      return concat(parts);\n\n    case \"Program\":\n      // Babel 6\n      if (n.directives) {\n        path.each(function (childPath) {\n          parts.push(print(childPath), semi, hardline);\n\n          if (isNextLineEmpty(options.originalText, childPath.getValue(), options)) {\n            parts.push(hardline);\n          }\n        }, \"directives\");\n      }\n\n      parts.push(path.call(function (bodyPath) {\n        return printStatementSequence(bodyPath, options, print);\n      }, \"body\"));\n      parts.push(comments.printDanglingComments(path, options,\n      /* sameIndent */\n      true)); // Only force a trailing newline if there were any contents.\n\n      if (n.body.length || n.comments) {\n        parts.push(hardline);\n      }\n\n      return concat(parts);\n    // Babel extension.\n\n    case \"EmptyStatement\":\n      return \"\";\n\n    case \"ExpressionStatement\":\n      // Detect Flow-parsed directives\n      if (n.directive) {\n        return concat([nodeStr(n.expression, options, true), semi]);\n      }\n\n      if (options.parser === \"__vue_event_binding\") {\n        var parent = path.getParentNode();\n\n        if (parent.type === \"Program\" && parent.body.length === 1 && parent.body[0] === n) {\n          return concat([path.call(print, \"expression\"), isVueEventBindingExpression(n.expression) ? \";\" : \"\"]);\n        }\n      } // Do not append semicolon after the only JSX element in a program\n\n\n      return concat([path.call(print, \"expression\"), isTheOnlyJSXElementInMarkdown(options, path) ? \"\" : semi]);\n    // Babel extension.\n\n    case \"ParenthesizedExpression\":\n      return concat([\"(\", path.call(print, \"expression\"), \")\"]);\n\n    case \"AssignmentExpression\":\n      return printAssignment(n.left, path.call(print, \"left\"), concat([\" \", n.operator]), n.right, path.call(print, \"right\"), options);\n\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n    case \"NGPipeExpression\":\n      {\n        var _parent = path.getParentNode();\n\n        var parentParent = path.getParentNode(1);\n        var isInsideParenthesis = n !== _parent.body && (_parent.type === \"IfStatement\" || _parent.type === \"WhileStatement\" || _parent.type === \"DoWhileStatement\");\n\n        var _parts = printBinaryishExpressions(path, print, options,\n        /* isNested */\n        false, isInsideParenthesis); //   if (\n        //     this.hasPlugin(\"dynamicImports\") && this.lookahead().type === tt.parenLeft\n        //   ) {\n        //\n        // looks super weird, we want to break the children if the parent breaks\n        //\n        //   if (\n        //     this.hasPlugin(\"dynamicImports\") &&\n        //     this.lookahead().type === tt.parenLeft\n        //   ) {\n\n\n        if (isInsideParenthesis) {\n          return concat(_parts);\n        } // Break between the parens in\n        // unaries or in a member or specific call expression, i.e.\n        //\n        //   (\n        //     a &&\n        //     b &&\n        //     c\n        //   ).call()\n\n\n        if (_parent.type === \"CallExpression\" && _parent.callee === n || _parent.type === \"UnaryExpression\" || (_parent.type === \"MemberExpression\" || _parent.type === \"OptionalMemberExpression\") && !_parent.computed) {\n          return group(concat([indent(concat([softline, concat(_parts)])), softline]));\n        } // Avoid indenting sub-expressions in some cases where the first sub-expression is already\n        // indented accordingly. We should indent sub-expressions where the first case isn't indented.\n\n\n        var shouldNotIndent = _parent.type === \"ReturnStatement\" || _parent.type === \"JSXExpressionContainer\" && parentParent.type === \"JSXAttribute\" || n.type !== \"NGPipeExpression\" && (_parent.type === \"NGRoot\" && options.parser === \"__ng_binding\" || _parent.type === \"NGMicrosyntaxExpression\" && parentParent.type === \"NGMicrosyntax\" && parentParent.body.length === 1) || n === _parent.body && _parent.type === \"ArrowFunctionExpression\" || n !== _parent.body && _parent.type === \"ForStatement\" || _parent.type === \"ConditionalExpression\" && parentParent.type !== \"ReturnStatement\" && parentParent.type !== \"CallExpression\";\n        var shouldIndentIfInlining = _parent.type === \"AssignmentExpression\" || _parent.type === \"VariableDeclarator\" || _parent.type === \"ClassProperty\" || _parent.type === \"TSAbstractClassProperty\" || _parent.type === \"ClassPrivateProperty\" || _parent.type === \"ObjectProperty\" || _parent.type === \"Property\";\n        var samePrecedenceSubExpression = isBinaryish(n.left) && shouldFlatten(n.operator, n.left.operator);\n\n        if (shouldNotIndent || shouldInlineLogicalExpression(n) && !samePrecedenceSubExpression || !shouldInlineLogicalExpression(n) && shouldIndentIfInlining) {\n          return group(concat(_parts));\n        }\n\n        if (_parts.length === 0) {\n          return \"\";\n        } // If the right part is a JSX node, we include it in a separate group to\n        // prevent it breaking the whole chain, so we can print the expression like:\n        //\n        //   foo && bar && (\n        //     <Foo>\n        //       <Bar />\n        //     </Foo>\n        //   )\n\n\n        var hasJSX = isJSXNode(n.right);\n        var rest = concat(hasJSX ? _parts.slice(1, -1) : _parts.slice(1));\n        var groupId = Symbol(\"logicalChain-\" + ++uid);\n        var chain = group(concat([// Don't include the initial expression in the indentation\n        // level. The first item is guaranteed to be the first\n        // left-most expression.\n        _parts.length > 0 ? _parts[0] : \"\", indent(rest)]), {\n          id: groupId\n        });\n\n        if (!hasJSX) {\n          return chain;\n        }\n\n        var jsxPart = getLast(_parts);\n        return group(concat([chain, ifBreak(indent(jsxPart), jsxPart, {\n          groupId: groupId\n        })]));\n      }\n\n    case \"AssignmentPattern\":\n      return concat([path.call(print, \"left\"), \" = \", path.call(print, \"right\")]);\n\n    case \"TSTypeAssertion\":\n      {\n        var shouldBreakAfterCast = !(n.expression.type === \"ArrayExpression\" || n.expression.type === \"ObjectExpression\");\n        var castGroup = group(concat([\"<\", indent(concat([softline, path.call(print, \"typeAnnotation\")])), softline, \">\"]));\n        var exprContents = concat([ifBreak(\"(\"), indent(concat([softline, path.call(print, \"expression\")])), softline, ifBreak(\")\")]);\n\n        if (shouldBreakAfterCast) {\n          return conditionalGroup([concat([castGroup, path.call(print, \"expression\")]), concat([castGroup, group(exprContents, {\n            shouldBreak: true\n          })]), concat([castGroup, path.call(print, \"expression\")])]);\n        }\n\n        return group(concat([castGroup, path.call(print, \"expression\")]));\n      }\n\n    case \"OptionalMemberExpression\":\n    case \"MemberExpression\":\n      {\n        var _parent2 = path.getParentNode();\n\n        var firstNonMemberParent;\n        var i = 0;\n\n        do {\n          firstNonMemberParent = path.getParentNode(i);\n          i++;\n        } while (firstNonMemberParent && (firstNonMemberParent.type === \"MemberExpression\" || firstNonMemberParent.type === \"OptionalMemberExpression\" || firstNonMemberParent.type === \"TSNonNullExpression\"));\n\n        var shouldInline = firstNonMemberParent && (firstNonMemberParent.type === \"NewExpression\" || firstNonMemberParent.type === \"BindExpression\" || firstNonMemberParent.type === \"VariableDeclarator\" && firstNonMemberParent.id.type !== \"Identifier\" || firstNonMemberParent.type === \"AssignmentExpression\" && firstNonMemberParent.left.type !== \"Identifier\") || n.computed || n.object.type === \"Identifier\" && n.property.type === \"Identifier\" && _parent2.type !== \"MemberExpression\" && _parent2.type !== \"OptionalMemberExpression\";\n        return concat([path.call(print, \"object\"), shouldInline ? printMemberLookup(path, options, print) : group(indent(concat([softline, printMemberLookup(path, options, print)])))]);\n      }\n\n    case \"MetaProperty\":\n      return concat([path.call(print, \"meta\"), \".\", path.call(print, \"property\")]);\n\n    case \"BindExpression\":\n      if (n.object) {\n        parts.push(path.call(print, \"object\"));\n      }\n\n      parts.push(group(indent(concat([softline, printBindExpressionCallee(path, options, print)]))));\n      return concat(parts);\n\n    case \"Identifier\":\n      {\n        return concat([n.name, printOptionalToken(path), printTypeAnnotation(path, options, print)]);\n      }\n\n    case \"SpreadElement\":\n    case \"SpreadElementPattern\":\n    case \"RestProperty\":\n    case \"SpreadProperty\":\n    case \"SpreadPropertyPattern\":\n    case \"RestElement\":\n    case \"ObjectTypeSpreadProperty\":\n      return concat([\"...\", path.call(print, \"argument\"), printTypeAnnotation(path, options, print)]);\n\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n      parts.push(printFunctionDeclaration(path, print, options));\n\n      if (!n.body) {\n        parts.push(semi);\n      }\n\n      return concat(parts);\n\n    case \"ArrowFunctionExpression\":\n      {\n        if (n.async) {\n          parts.push(\"async \");\n        }\n\n        if (shouldPrintParamsWithoutParens(path, options)) {\n          parts.push(path.call(print, \"params\", 0));\n        } else {\n          parts.push(group(concat([printFunctionParams(path, print, options,\n          /* expandLast */\n          args && (args.expandLastArg || args.expandFirstArg),\n          /* printTypeParams */\n          true), printReturnType(path, print, options)])));\n        }\n\n        var dangling = comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true, function (comment) {\n          var nextCharacter = getNextNonSpaceNonCommentCharacterIndex(options.originalText, comment, options);\n          return options.originalText.substr(nextCharacter, 2) === \"=>\";\n        });\n\n        if (dangling) {\n          parts.push(\" \", dangling);\n        }\n\n        parts.push(\" =>\");\n        var body = path.call(function (bodyPath) {\n          return print(bodyPath, args);\n        }, \"body\"); // We want to always keep these types of nodes on the same line\n        // as the arrow.\n\n        if (!hasLeadingOwnLineComment(options.originalText, n.body, options) && (n.body.type === \"ArrayExpression\" || n.body.type === \"ObjectExpression\" || n.body.type === \"BlockStatement\" || isJSXNode(n.body) || isTemplateOnItsOwnLine(n.body, options.originalText, options) || n.body.type === \"ArrowFunctionExpression\" || n.body.type === \"DoExpression\")) {\n          return group(concat([concat(parts), \" \", body]));\n        } // We handle sequence expressions as the body of arrows specially,\n        // so that the required parentheses end up on their own lines.\n\n\n        if (n.body.type === \"SequenceExpression\") {\n          return group(concat([concat(parts), group(concat([\" (\", indent(concat([softline, body])), softline, \")\"]))]));\n        } // if the arrow function is expanded as last argument, we are adding a\n        // level of indentation and need to add a softline to align the closing )\n        // with the opening (, or if it's inside a JSXExpression (e.g. an attribute)\n        // we should align the expression's closing } with the line with the opening {.\n\n\n        var shouldAddSoftLine = (args && args.expandLastArg || path.getParentNode().type === \"JSXExpressionContainer\") && !(n.comments && n.comments.length);\n        var printTrailingComma = args && args.expandLastArg && shouldPrintComma(options, \"all\"); // In order to avoid confusion between\n        // a => a ? a : a\n        // a <= a ? a : a\n\n        var shouldAddParens = n.body.type === \"ConditionalExpression\" && !startsWithNoLookaheadToken(n.body,\n        /* forbidFunctionAndClass */\n        false);\n        return group(concat([concat(parts), group(concat([indent(concat([line, shouldAddParens ? ifBreak(\"\", \"(\") : \"\", body, shouldAddParens ? ifBreak(\"\", \")\") : \"\"])), shouldAddSoftLine ? concat([ifBreak(printTrailingComma ? \",\" : \"\"), softline]) : \"\"]))]));\n      }\n\n    case \"MethodDefinition\":\n    case \"TSAbstractMethodDefinition\":\n      if (n.decorators && n.decorators.length !== 0) {\n        parts.push(printDecorators(path, options, print));\n      }\n\n      if (n.accessibility) {\n        parts.push(n.accessibility + \" \");\n      }\n\n      if (n[\"static\"]) {\n        parts.push(\"static \");\n      }\n\n      if (n.type === \"TSAbstractMethodDefinition\") {\n        parts.push(\"abstract \");\n      }\n\n      parts.push(printMethod(path, options, print));\n      return concat(parts);\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n\n      if (n.delegate) {\n        parts.push(\"*\");\n      }\n\n      if (n.argument) {\n        parts.push(\" \", path.call(print, \"argument\"));\n      }\n\n      return concat(parts);\n\n    case \"AwaitExpression\":\n      return concat([\"await \", path.call(print, \"argument\")]);\n\n    case \"ImportSpecifier\":\n      if (n.importKind) {\n        parts.push(path.call(print, \"importKind\"), \" \");\n      }\n\n      parts.push(path.call(print, \"imported\"));\n\n      if (n.local && n.local.name !== n.imported.name) {\n        parts.push(\" as \", path.call(print, \"local\"));\n      }\n\n      return concat(parts);\n\n    case \"ExportSpecifier\":\n      parts.push(path.call(print, \"local\"));\n\n      if (n.exported && n.exported.name !== n.local.name) {\n        parts.push(\" as \", path.call(print, \"exported\"));\n      }\n\n      return concat(parts);\n\n    case \"ImportNamespaceSpecifier\":\n      parts.push(\"* as \");\n      parts.push(path.call(print, \"local\"));\n      return concat(parts);\n\n    case \"ImportDefaultSpecifier\":\n      return path.call(print, \"local\");\n\n    case \"TSExportAssignment\":\n      return concat([\"export = \", path.call(print, \"expression\"), semi]);\n\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n      return printExportDeclaration(path, options, print);\n\n    case \"ExportAllDeclaration\":\n      parts.push(\"export \");\n\n      if (n.exportKind === \"type\") {\n        parts.push(\"type \");\n      }\n\n      parts.push(\"* from \", path.call(print, \"source\"), semi);\n      return concat(parts);\n\n    case \"ExportNamespaceSpecifier\":\n    case \"ExportDefaultSpecifier\":\n      return path.call(print, \"exported\");\n\n    case \"ImportDeclaration\":\n      {\n        parts.push(\"import \");\n\n        if (n.importKind && n.importKind !== \"value\") {\n          parts.push(n.importKind + \" \");\n        }\n\n        var standalones = [];\n        var grouped = [];\n\n        if (n.specifiers && n.specifiers.length > 0) {\n          path.each(function (specifierPath) {\n            var value = specifierPath.getValue();\n\n            if (value.type === \"ImportDefaultSpecifier\" || value.type === \"ImportNamespaceSpecifier\") {\n              standalones.push(print(specifierPath));\n            } else {\n              grouped.push(print(specifierPath));\n            }\n          }, \"specifiers\");\n\n          if (standalones.length > 0) {\n            parts.push(join(\", \", standalones));\n          }\n\n          if (standalones.length > 0 && grouped.length > 0) {\n            parts.push(\", \");\n          }\n\n          if (grouped.length === 1 && standalones.length === 0 && n.specifiers && !n.specifiers.some(function (node) {\n            return node.comments;\n          })) {\n            parts.push(concat([\"{\", options.bracketSpacing ? \" \" : \"\", concat(grouped), options.bracketSpacing ? \" \" : \"\", \"}\"]));\n          } else if (grouped.length >= 1) {\n            parts.push(group(concat([\"{\", indent(concat([options.bracketSpacing ? line : softline, join(concat([\",\", line]), grouped)])), ifBreak(shouldPrintComma(options) ? \",\" : \"\"), options.bracketSpacing ? line : softline, \"}\"])));\n          }\n\n          parts.push(\" from \");\n        } else if (n.importKind && n.importKind === \"type\" || // import {} from 'x'\n        /{\\s*}/.test(options.originalText.slice(options.locStart(n), options.locStart(n.source)))) {\n          parts.push(\"{} from \");\n        }\n\n        parts.push(path.call(print, \"source\"), semi);\n        return concat(parts);\n      }\n\n    case \"Import\":\n      return \"import\";\n\n    case \"TSModuleBlock\":\n    case \"BlockStatement\":\n      {\n        var naked = path.call(function (bodyPath) {\n          return printStatementSequence(bodyPath, options, print);\n        }, \"body\");\n        var hasContent = n.body.find(function (node) {\n          return node.type !== \"EmptyStatement\";\n        });\n        var hasDirectives = n.directives && n.directives.length > 0;\n\n        var _parent3 = path.getParentNode();\n\n        var _parentParent = path.getParentNode(1);\n\n        if (!hasContent && !hasDirectives && !hasDanglingComments(n) && (_parent3.type === \"ArrowFunctionExpression\" || _parent3.type === \"FunctionExpression\" || _parent3.type === \"FunctionDeclaration\" || _parent3.type === \"ObjectMethod\" || _parent3.type === \"ClassMethod\" || _parent3.type === \"ClassPrivateMethod\" || _parent3.type === \"ForStatement\" || _parent3.type === \"WhileStatement\" || _parent3.type === \"DoWhileStatement\" || _parent3.type === \"DoExpression\" || _parent3.type === \"CatchClause\" && !_parentParent.finalizer || _parent3.type === \"TSModuleDeclaration\")) {\n          return \"{}\";\n        }\n\n        parts.push(\"{\"); // Babel 6\n\n        if (hasDirectives) {\n          path.each(function (childPath) {\n            parts.push(indent(concat([hardline, print(childPath), semi])));\n\n            if (isNextLineEmpty(options.originalText, childPath.getValue(), options)) {\n              parts.push(hardline);\n            }\n          }, \"directives\");\n        }\n\n        if (hasContent) {\n          parts.push(indent(concat([hardline, naked])));\n        }\n\n        parts.push(comments.printDanglingComments(path, options));\n        parts.push(hardline, \"}\");\n        return concat(parts);\n      }\n\n    case \"ReturnStatement\":\n      parts.push(\"return\");\n\n      if (n.argument) {\n        if (returnArgumentHasLeadingComment(options, n.argument)) {\n          parts.push(concat([\" (\", indent(concat([hardline, path.call(print, \"argument\")])), hardline, \")\"]));\n        } else if (n.argument.type === \"LogicalExpression\" || n.argument.type === \"BinaryExpression\" || n.argument.type === \"SequenceExpression\") {\n          parts.push(group(concat([ifBreak(\" (\", \" \"), indent(concat([softline, path.call(print, \"argument\")])), softline, ifBreak(\")\")])));\n        } else {\n          parts.push(\" \", path.call(print, \"argument\"));\n        }\n      }\n\n      if (hasDanglingComments(n)) {\n        parts.push(\" \", comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true));\n      }\n\n      parts.push(semi);\n      return concat(parts);\n\n    case \"NewExpression\":\n    case \"OptionalCallExpression\":\n    case \"CallExpression\":\n      {\n        var isNew = n.type === \"NewExpression\";\n        var optional = printOptionalToken(path);\n\n        if ( // We want to keep CommonJS- and AMD-style require calls, and AMD-style\n        // define calls, as a unit.\n        // e.g. `define([\"some/lib\", (lib) => {`\n        !isNew && n.callee.type === \"Identifier\" && (n.callee.name === \"require\" || n.callee.name === \"define\") || // Template literals as single arguments\n        n.arguments.length === 1 && isTemplateOnItsOwnLine(n.arguments[0], options.originalText, options) || // Keep test declarations on a single line\n        // e.g. `it('long name', () => {`\n        !isNew && isTestCall(n, path.getParentNode())) {\n          return concat([isNew ? \"new \" : \"\", path.call(print, \"callee\"), optional, printFunctionTypeParameters(path, options, print), concat([\"(\", join(\", \", path.map(print, \"arguments\")), \")\"])]);\n        } // Inline Flow annotation comments following Identifiers in Call nodes need to\n        // stay with the Identifier. For example:\n        //\n        // foo /*:: <SomeGeneric> */(bar);\n        //\n        // Here, we ensure that such comments stay between the Identifier and the Callee.\n\n\n        var isIdentifierWithFlowAnnotation = n.callee.type === \"Identifier\" && hasFlowAnnotationComment(n.callee.trailingComments);\n\n        if (isIdentifierWithFlowAnnotation) {\n          n.callee.trailingComments[0].printed = true;\n        } // We detect calls on member lookups and possibly print them in a\n        // special chain format. See `printMemberChain` for more info.\n\n\n        if (!isNew && isMemberish(n.callee)) {\n          return printMemberChain(path, options, print);\n        }\n\n        return concat([isNew ? \"new \" : \"\", path.call(print, \"callee\"), optional, isIdentifierWithFlowAnnotation ? \"/*:: \".concat(n.callee.trailingComments[0].value.substring(2).trim(), \" */\") : \"\", printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)]);\n      }\n\n    case \"TSInterfaceDeclaration\":\n      if (isNodeStartingWithDeclare(n, options)) {\n        parts.push(\"declare \");\n      }\n\n      parts.push(n[\"abstract\"] ? \"abstract \" : \"\", printTypeScriptModifiers(path, options, print), \"interface \", path.call(print, \"id\"), n.typeParameters ? path.call(print, \"typeParameters\") : \"\", \" \");\n\n      if (n[\"extends\"] && n[\"extends\"].length) {\n        parts.push(group(indent(concat([softline, \"extends \", (n[\"extends\"].length === 1 ? identity : indent)(join(concat([\",\", line]), path.map(print, \"extends\"))), \" \"]))));\n      }\n\n      parts.push(path.call(print, \"body\"));\n      return concat(parts);\n\n    case \"ObjectTypeInternalSlot\":\n      return concat([n[\"static\"] ? \"static \" : \"\", \"[[\", path.call(print, \"id\"), \"]]\", printOptionalToken(path), n.method ? \"\" : \": \", path.call(print, \"value\")]);\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n    case \"ObjectTypeAnnotation\":\n    case \"TSInterfaceBody\":\n    case \"TSTypeLiteral\":\n      {\n        var propertiesField;\n\n        if (n.type === \"TSTypeLiteral\") {\n          propertiesField = \"members\";\n        } else if (n.type === \"TSInterfaceBody\") {\n          propertiesField = \"body\";\n        } else {\n          propertiesField = \"properties\";\n        }\n\n        var isTypeAnnotation = n.type === \"ObjectTypeAnnotation\";\n        var fields = [];\n\n        if (isTypeAnnotation) {\n          fields.push(\"indexers\", \"callProperties\", \"internalSlots\");\n        }\n\n        fields.push(propertiesField);\n        var firstProperty = fields.map(function (field) {\n          return n[field][0];\n        }).sort(function (a, b) {\n          return options.locStart(a) - options.locStart(b);\n        })[0];\n\n        var _parent4 = path.getParentNode(0);\n\n        var isFlowInterfaceLikeBody = isTypeAnnotation && _parent4 && (_parent4.type === \"InterfaceDeclaration\" || _parent4.type === \"DeclareInterface\" || _parent4.type === \"DeclareClass\") && path.getName() === \"body\";\n        var shouldBreak = n.type === \"TSInterfaceBody\" || isFlowInterfaceLikeBody || n.type === \"ObjectPattern\" && _parent4.type !== \"FunctionDeclaration\" && _parent4.type !== \"FunctionExpression\" && _parent4.type !== \"ArrowFunctionExpression\" && _parent4.type !== \"AssignmentPattern\" && _parent4.type !== \"CatchClause\" && n.properties.some(function (property) {\n          return property.value && (property.value.type === \"ObjectPattern\" || property.value.type === \"ArrayPattern\");\n        }) || n.type !== \"ObjectPattern\" && firstProperty && hasNewlineInRange(options.originalText, options.locStart(n), options.locStart(firstProperty));\n        var separator = isFlowInterfaceLikeBody ? \";\" : n.type === \"TSInterfaceBody\" || n.type === \"TSTypeLiteral\" ? ifBreak(semi, \";\") : \",\";\n        var leftBrace = n.exact ? \"{|\" : \"{\";\n        var rightBrace = n.exact ? \"|}\" : \"}\"; // Unfortunately, things are grouped together in the ast can be\n        // interleaved in the source code. So we need to reorder them before\n        // printing them.\n\n        var propsAndLoc = [];\n        fields.forEach(function (field) {\n          path.each(function (childPath) {\n            var node = childPath.getValue();\n            propsAndLoc.push({\n              node: node,\n              printed: print(childPath),\n              loc: options.locStart(node)\n            });\n          }, field);\n        });\n        var separatorParts = [];\n        var props = propsAndLoc.sort(function (a, b) {\n          return a.loc - b.loc;\n        }).map(function (prop) {\n          var result = concat(separatorParts.concat(group(prop.printed)));\n          separatorParts = [separator, line];\n\n          if ((prop.node.type === \"TSPropertySignature\" || prop.node.type === \"TSMethodSignature\" || prop.node.type === \"TSConstructSignatureDeclaration\") && hasNodeIgnoreComment(prop.node)) {\n            separatorParts.shift();\n          }\n\n          if (isNextLineEmpty(options.originalText, prop.node, options)) {\n            separatorParts.push(hardline);\n          }\n\n          return result;\n        });\n\n        if (n.inexact) {\n          props.push(concat(separatorParts.concat(group(\"...\"))));\n        }\n\n        var lastElem = getLast(n[propertiesField]);\n        var canHaveTrailingSeparator = !(lastElem && (lastElem.type === \"RestProperty\" || lastElem.type === \"RestElement\" || hasNodeIgnoreComment(lastElem) || n.inexact));\n        var content;\n\n        if (props.length === 0) {\n          if (!hasDanglingComments(n)) {\n            return concat([leftBrace, rightBrace, printTypeAnnotation(path, options, print)]);\n          }\n\n          content = group(concat([leftBrace, comments.printDanglingComments(path, options), softline, rightBrace, printOptionalToken(path), printTypeAnnotation(path, options, print)]));\n        } else {\n          content = concat([leftBrace, indent(concat([options.bracketSpacing ? line : softline, concat(props)])), ifBreak(canHaveTrailingSeparator && (separator !== \",\" || shouldPrintComma(options)) ? separator : \"\"), concat([options.bracketSpacing ? line : softline, rightBrace]), printOptionalToken(path), printTypeAnnotation(path, options, print)]);\n        } // If we inline the object as first argument of the parent, we don't want\n        // to create another group so that the object breaks before the return\n        // type\n\n\n        var parentParentParent = path.getParentNode(2);\n\n        if (n.type === \"ObjectPattern\" && _parent4 && shouldHugArguments(_parent4) && !n.decorators && _parent4.params[0] === n || shouldHugType(n) && parentParentParent && shouldHugArguments(parentParentParent) && parentParentParent.params[0].typeAnnotation && parentParentParent.params[0].typeAnnotation.typeAnnotation === n) {\n          return content;\n        }\n\n        return group(content, {\n          shouldBreak: shouldBreak\n        });\n      }\n    // Babel 6\n\n    case \"ObjectProperty\": // Non-standard AST node type.\n\n    case \"Property\":\n      if (n.method || n.kind === \"get\" || n.kind === \"set\") {\n        return printMethod(path, options, print);\n      }\n\n      if (n.shorthand) {\n        parts.push(path.call(print, \"value\"));\n      } else {\n        var printedLeft;\n\n        if (n.computed) {\n          printedLeft = concat([\"[\", path.call(print, \"key\"), \"]\"]);\n        } else {\n          printedLeft = printPropertyKey(path, options, print);\n        }\n\n        parts.push(printAssignment(n.key, printedLeft, \":\", n.value, path.call(print, \"value\"), options));\n      }\n\n      return concat(parts);\n    // Babel 6\n\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      if (n.decorators && n.decorators.length !== 0) {\n        parts.push(printDecorators(path, options, print));\n      }\n\n      if (n[\"static\"]) {\n        parts.push(\"static \");\n      }\n\n      parts = parts.concat(printObjectMethod(path, options, print));\n      return concat(parts);\n    // Babel 6\n\n    case \"ObjectMethod\":\n      return printObjectMethod(path, options, print);\n\n    case \"Decorator\":\n      return concat([\"@\", path.call(print, \"expression\"), path.call(print, \"callee\")]);\n\n    case \"ArrayExpression\":\n    case \"ArrayPattern\":\n      if (n.elements.length === 0) {\n        if (!hasDanglingComments(n)) {\n          parts.push(\"[]\");\n        } else {\n          parts.push(group(concat([\"[\", comments.printDanglingComments(path, options), softline, \"]\"])));\n        }\n      } else {\n        var _lastElem = getLast(n.elements);\n\n        var canHaveTrailingComma = !(_lastElem && _lastElem.type === \"RestElement\"); // JavaScript allows you to have empty elements in an array which\n        // changes its length based on the number of commas. The algorithm\n        // is that if the last argument is null, we need to force insert\n        // a comma to ensure JavaScript recognizes it.\n        //   [,].length === 1\n        //   [1,].length === 1\n        //   [1,,].length === 2\n        //\n        // Note that getLast returns null if the array is empty, but\n        // we already check for an empty array just above so we are safe\n\n        var needsForcedTrailingComma = canHaveTrailingComma && _lastElem === null;\n        parts.push(group(concat([\"[\", indent(concat([softline, printArrayItems(path, options, \"elements\", print)])), needsForcedTrailingComma ? \",\" : \"\", ifBreak(canHaveTrailingComma && !needsForcedTrailingComma && shouldPrintComma(options) ? \",\" : \"\"), comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true), softline, \"]\"])));\n      }\n\n      parts.push(printOptionalToken(path), printTypeAnnotation(path, options, print));\n      return concat(parts);\n\n    case \"SequenceExpression\":\n      {\n        var _parent5 = path.getParentNode(0);\n\n        if (_parent5.type === \"ExpressionStatement\" || _parent5.type === \"ForStatement\") {\n          // For ExpressionStatements and for-loop heads, which are among\n          // the few places a SequenceExpression appears unparenthesized, we want\n          // to indent expressions after the first.\n          var _parts2 = [];\n          path.each(function (p) {\n            if (p.getName() === 0) {\n              _parts2.push(print(p));\n            } else {\n              _parts2.push(\",\", indent(concat([line, print(p)])));\n            }\n          }, \"expressions\");\n          return group(concat(_parts2));\n        }\n\n        return group(concat([join(concat([\",\", line]), path.map(print, \"expressions\"))]));\n      }\n\n    case \"ThisExpression\":\n      return \"this\";\n\n    case \"Super\":\n      return \"super\";\n\n    case \"NullLiteral\":\n      // Babel 6 Literal split\n      return \"null\";\n\n    case \"RegExpLiteral\":\n      // Babel 6 Literal split\n      return printRegex(n);\n\n    case \"NumericLiteral\":\n      // Babel 6 Literal split\n      return printNumber(n.extra.raw);\n\n    case \"BigIntLiteral\":\n      return concat([printNumber(n.extra ? n.extra.rawValue : // TypeScript\n      n.value), \"n\"]);\n\n    case \"BooleanLiteral\": // Babel 6 Literal split\n\n    case \"StringLiteral\": // Babel 6 Literal split\n\n    case \"Literal\":\n      {\n        if (n.regex) {\n          return printRegex(n.regex);\n        }\n\n        if (typeof n.value === \"number\") {\n          return printNumber(n.raw);\n        }\n\n        if (typeof n.value !== \"string\") {\n          return \"\" + n.value;\n        } // TypeScript workaround for https://github.com/JamesHenry/typescript-estree/issues/2\n        // See corresponding workaround in needs-parens.js\n\n\n        var grandParent = path.getParentNode(1);\n        var isTypeScriptDirective = options.parser === \"typescript\" && typeof n.value === \"string\" && grandParent && (grandParent.type === \"Program\" || grandParent.type === \"BlockStatement\");\n        return nodeStr(n, options, isTypeScriptDirective);\n      }\n\n    case \"Directive\":\n      return path.call(print, \"value\");\n    // Babel 6\n\n    case \"DirectiveLiteral\":\n      return nodeStr(n, options);\n\n    case \"UnaryExpression\":\n      parts.push(n.operator);\n\n      if (/[a-z]$/.test(n.operator)) {\n        parts.push(\" \");\n      }\n\n      if (n.argument.comments && n.argument.comments.length > 0) {\n        parts.push(group(concat([\"(\", indent(concat([softline, path.call(print, \"argument\")])), softline, \")\"])));\n      } else {\n        parts.push(path.call(print, \"argument\"));\n      }\n\n      return concat(parts);\n\n    case \"UpdateExpression\":\n      parts.push(path.call(print, \"argument\"), n.operator);\n\n      if (n.prefix) {\n        parts.reverse();\n      }\n\n      return concat(parts);\n\n    case \"ConditionalExpression\":\n      return printTernaryOperator(path, options, print, {\n        beforeParts: function beforeParts() {\n          return [path.call(print, \"test\")];\n        },\n        afterParts: function afterParts(breakClosingParen) {\n          return [breakClosingParen ? softline : \"\"];\n        },\n        shouldCheckJsx: true,\n        conditionalNodeType: \"ConditionalExpression\",\n        consequentNodePropertyName: \"consequent\",\n        alternateNodePropertyName: \"alternate\",\n        testNodePropertyName: \"test\",\n        breakNested: true\n      });\n\n    case \"VariableDeclaration\":\n      {\n        var printed = path.map(function (childPath) {\n          return print(childPath);\n        }, \"declarations\"); // We generally want to terminate all variable declarations with a\n        // semicolon, except when they in the () part of for loops.\n\n        var parentNode = path.getParentNode();\n        var isParentForLoop = parentNode.type === \"ForStatement\" || parentNode.type === \"ForInStatement\" || parentNode.type === \"ForOfStatement\" || parentNode.type === \"ForAwaitStatement\";\n        var hasValue = n.declarations.some(function (decl) {\n          return decl.init;\n        });\n        var firstVariable;\n\n        if (printed.length === 1 && !n.declarations[0].comments) {\n          firstVariable = printed[0];\n        } else if (printed.length > 0) {\n          // Indent first var to comply with eslint one-var rule\n          firstVariable = indent(printed[0]);\n        }\n\n        parts = [isNodeStartingWithDeclare(n, options) ? \"declare \" : \"\", n.kind, firstVariable ? concat([\" \", firstVariable]) : \"\", indent(concat(printed.slice(1).map(function (p) {\n          return concat([\",\", hasValue && !isParentForLoop ? hardline : line, p]);\n        })))];\n\n        if (!(isParentForLoop && parentNode.body !== n)) {\n          parts.push(semi);\n        }\n\n        return group(concat(parts));\n      }\n\n    case \"TSTypeAliasDeclaration\":\n      {\n        if (n.declare) {\n          parts.push(\"declare \");\n        }\n\n        var _printed = printAssignmentRight(n.id, n.typeAnnotation, n.typeAnnotation && path.call(print, \"typeAnnotation\"), options);\n\n        parts.push(\"type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"), \" =\", _printed, semi);\n        return group(concat(parts));\n      }\n\n    case \"VariableDeclarator\":\n      return printAssignment(n.id, path.call(print, \"id\"), \" =\", n.init, n.init && path.call(print, \"init\"), options);\n\n    case \"WithStatement\":\n      return group(concat([\"with (\", path.call(print, \"object\"), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n\n    case \"IfStatement\":\n      {\n        var con = adjustClause(n.consequent, path.call(print, \"consequent\"));\n        var opening = group(concat([\"if (\", group(concat([indent(concat([softline, path.call(print, \"test\")])), softline])), \")\", con]));\n        parts.push(opening);\n\n        if (n.alternate) {\n          var commentOnOwnLine = hasTrailingComment(n.consequent) && n.consequent.comments.some(function (comment) {\n            return comment.trailing && !handleComments.isBlockComment(comment);\n          }) || needsHardlineAfterDanglingComment(n);\n          var elseOnSameLine = n.consequent.type === \"BlockStatement\" && !commentOnOwnLine;\n          parts.push(elseOnSameLine ? \" \" : hardline);\n\n          if (hasDanglingComments(n)) {\n            parts.push(comments.printDanglingComments(path, options, true), commentOnOwnLine ? hardline : \" \");\n          }\n\n          parts.push(\"else\", group(adjustClause(n.alternate, path.call(print, \"alternate\"), n.alternate.type === \"IfStatement\")));\n        }\n\n        return concat(parts);\n      }\n\n    case \"ForStatement\":\n      {\n        var _body = adjustClause(n.body, path.call(print, \"body\")); // We want to keep dangling comments above the loop to stay consistent.\n        // Any comment positioned between the for statement and the parentheses\n        // is going to be printed before the statement.\n\n\n        var _dangling = comments.printDanglingComments(path, options,\n        /* sameLine */\n        true);\n\n        var printedComments = _dangling ? concat([_dangling, softline]) : \"\";\n\n        if (!n.init && !n.test && !n.update) {\n          return concat([printedComments, group(concat([\"for (;;)\", _body]))]);\n        }\n\n        return concat([printedComments, group(concat([\"for (\", group(concat([indent(concat([softline, path.call(print, \"init\"), \";\", line, path.call(print, \"test\"), \";\", line, path.call(print, \"update\")])), softline])), \")\", _body]))]);\n      }\n\n    case \"WhileStatement\":\n      return group(concat([\"while (\", group(concat([indent(concat([softline, path.call(print, \"test\")])), softline])), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n\n    case \"ForInStatement\":\n      // Note: esprima can't actually parse \"for each (\".\n      return group(concat([n.each ? \"for each (\" : \"for (\", path.call(print, \"left\"), \" in \", path.call(print, \"right\"), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n\n    case \"ForOfStatement\":\n    case \"ForAwaitStatement\":\n      {\n        // Babel 7 removed ForAwaitStatement in favor of ForOfStatement\n        // with `\"await\": true`:\n        // https://github.com/estree/estree/pull/138\n        var isAwait = n.type === \"ForAwaitStatement\" || n[\"await\"];\n        return group(concat([\"for\", isAwait ? \" await\" : \"\", \" (\", path.call(print, \"left\"), \" of \", path.call(print, \"right\"), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n      }\n\n    case \"DoWhileStatement\":\n      {\n        var clause = adjustClause(n.body, path.call(print, \"body\"));\n        var doBody = group(concat([\"do\", clause]));\n        parts = [doBody];\n\n        if (n.body.type === \"BlockStatement\") {\n          parts.push(\" \");\n        } else {\n          parts.push(hardline);\n        }\n\n        parts.push(\"while (\");\n        parts.push(group(concat([indent(concat([softline, path.call(print, \"test\")])), softline])), \")\", semi);\n        return concat(parts);\n      }\n\n    case \"DoExpression\":\n      return concat([\"do \", path.call(print, \"body\")]);\n\n    case \"BreakStatement\":\n      parts.push(\"break\");\n\n      if (n.label) {\n        parts.push(\" \", path.call(print, \"label\"));\n      }\n\n      parts.push(semi);\n      return concat(parts);\n\n    case \"ContinueStatement\":\n      parts.push(\"continue\");\n\n      if (n.label) {\n        parts.push(\" \", path.call(print, \"label\"));\n      }\n\n      parts.push(semi);\n      return concat(parts);\n\n    case \"LabeledStatement\":\n      if (n.body.type === \"EmptyStatement\") {\n        return concat([path.call(print, \"label\"), \":;\"]);\n      }\n\n      return concat([path.call(print, \"label\"), \": \", path.call(print, \"body\")]);\n\n    case \"TryStatement\":\n      return concat([\"try \", path.call(print, \"block\"), n.handler ? concat([\" \", path.call(print, \"handler\")]) : \"\", n.finalizer ? concat([\" finally \", path.call(print, \"finalizer\")]) : \"\"]);\n\n    case \"CatchClause\":\n      if (n.param) {\n        var hasComments = n.param.comments && n.param.comments.some(function (comment) {\n          return !handleComments.isBlockComment(comment) || comment.leading && hasNewline(options.originalText, options.locEnd(comment)) || comment.trailing && hasNewline(options.originalText, options.locStart(comment), {\n            backwards: true\n          });\n        });\n        var param = path.call(print, \"param\");\n        return concat([\"catch \", hasComments ? concat([\"(\", indent(concat([softline, param])), softline, \") \"]) : concat([\"(\", param, \") \"]), path.call(print, \"body\")]);\n      }\n\n      return concat([\"catch \", path.call(print, \"body\")]);\n\n    case \"ThrowStatement\":\n      return concat([\"throw \", path.call(print, \"argument\"), semi]);\n    // Note: ignoring n.lexical because it has no printing consequences.\n\n    case \"SwitchStatement\":\n      return concat([group(concat([\"switch (\", indent(concat([softline, path.call(print, \"discriminant\")])), softline, \")\"])), \" {\", n.cases.length > 0 ? indent(concat([hardline, join(hardline, path.map(function (casePath) {\n        var caseNode = casePath.getValue();\n        return concat([casePath.call(print), n.cases.indexOf(caseNode) !== n.cases.length - 1 && isNextLineEmpty(options.originalText, caseNode, options) ? hardline : \"\"]);\n      }, \"cases\"))])) : \"\", hardline, \"}\"]);\n\n    case \"SwitchCase\":\n      {\n        if (n.test) {\n          parts.push(\"case \", path.call(print, \"test\"), \":\");\n        } else {\n          parts.push(\"default:\");\n        }\n\n        var consequent = n.consequent.filter(function (node) {\n          return node.type !== \"EmptyStatement\";\n        });\n\n        if (consequent.length > 0) {\n          var cons = path.call(function (consequentPath) {\n            return printStatementSequence(consequentPath, options, print);\n          }, \"consequent\");\n          parts.push(consequent.length === 1 && consequent[0].type === \"BlockStatement\" ? concat([\" \", cons]) : indent(concat([hardline, cons])));\n        }\n\n        return concat(parts);\n      }\n    // JSX extensions below.\n\n    case \"DebuggerStatement\":\n      return concat([\"debugger\", semi]);\n\n    case \"JSXAttribute\":\n      parts.push(path.call(print, \"name\"));\n\n      if (n.value) {\n        var res;\n\n        if (isStringLiteral(n.value)) {\n          var raw = rawText(n.value); // Unescape all quotes so we get an accurate preferred quote\n\n          var _final = raw.replace(/&apos;/g, \"'\").replace(/&quot;/g, '\"');\n\n          var quote = getPreferredQuote(_final, options.jsxSingleQuote ? \"'\" : '\"');\n\n          var _escape = quote === \"'\" ? \"&apos;\" : \"&quot;\";\n\n          _final = _final.replace(new RegExp(quote, \"g\"), _escape);\n          res = concat([quote, _final, quote]);\n        } else {\n          res = path.call(print, \"value\");\n        }\n\n        parts.push(\"=\", res);\n      }\n\n      return concat(parts);\n\n    case \"JSXIdentifier\":\n      return \"\" + n.name;\n\n    case \"JSXNamespacedName\":\n      return join(\":\", [path.call(print, \"namespace\"), path.call(print, \"name\")]);\n\n    case \"JSXMemberExpression\":\n      return join(\".\", [path.call(print, \"object\"), path.call(print, \"property\")]);\n\n    case \"TSQualifiedName\":\n      return join(\".\", [path.call(print, \"left\"), path.call(print, \"right\")]);\n\n    case \"JSXSpreadAttribute\":\n    case \"JSXSpreadChild\":\n      {\n        return concat([\"{\", path.call(function (p) {\n          var printed = concat([\"...\", print(p)]);\n          var n = p.getValue();\n\n          if (!n.comments || !n.comments.length) {\n            return printed;\n          }\n\n          return concat([indent(concat([softline, comments.printComments(p, function () {\n            return printed;\n          }, options)])), softline]);\n        }, n.type === \"JSXSpreadAttribute\" ? \"argument\" : \"expression\"), \"}\"]);\n      }\n\n    case \"JSXExpressionContainer\":\n      {\n        var _parent6 = path.getParentNode(0);\n\n        var preventInline = _parent6.type === \"JSXAttribute\" && n.expression.comments && n.expression.comments.length > 0;\n\n        var _shouldInline = !preventInline && (n.expression.type === \"ArrayExpression\" || n.expression.type === \"ObjectExpression\" || n.expression.type === \"ArrowFunctionExpression\" || n.expression.type === \"CallExpression\" || n.expression.type === \"OptionalCallExpression\" || n.expression.type === \"FunctionExpression\" || n.expression.type === \"JSXEmptyExpression\" || n.expression.type === \"TemplateLiteral\" || n.expression.type === \"TaggedTemplateExpression\" || n.expression.type === \"DoExpression\" || isJSXNode(_parent6) && (n.expression.type === \"ConditionalExpression\" || isBinaryish(n.expression)));\n\n        if (_shouldInline) {\n          return group(concat([\"{\", path.call(print, \"expression\"), lineSuffixBoundary, \"}\"]));\n        }\n\n        return group(concat([\"{\", indent(concat([softline, path.call(print, \"expression\")])), softline, lineSuffixBoundary, \"}\"]));\n      }\n\n    case \"JSXFragment\":\n    case \"JSXElement\":\n      {\n        var elem = comments.printComments(path, function () {\n          return printJSXElement(path, options, print);\n        }, options);\n        return maybeWrapJSXElementInParens(path, elem);\n      }\n\n    case \"JSXOpeningElement\":\n      {\n        var _n = path.getValue();\n\n        var nameHasComments = _n.name && _n.name.comments && _n.name.comments.length > 0 || _n.typeParameters && _n.typeParameters.comments && _n.typeParameters.comments.length > 0; // Don't break self-closing elements with no attributes and no comments\n\n        if (_n.selfClosing && !_n.attributes.length && !nameHasComments) {\n          return concat([\"<\", path.call(print, \"name\"), path.call(print, \"typeParameters\"), \" />\"]);\n        } // don't break up opening elements with a single long text attribute\n\n\n        if (_n.attributes && _n.attributes.length === 1 && _n.attributes[0].value && isStringLiteral(_n.attributes[0].value) && !_n.attributes[0].value.value.includes(\"\\n\") && // We should break for the following cases:\n        // <div\n        //   // comment\n        //   attr=\"value\"\n        // >\n        // <div\n        //   attr=\"value\"\n        //   // comment\n        // >\n        !nameHasComments && (!_n.attributes[0].comments || !_n.attributes[0].comments.length)) {\n          return group(concat([\"<\", path.call(print, \"name\"), path.call(print, \"typeParameters\"), \" \", concat(path.map(print, \"attributes\")), _n.selfClosing ? \" />\" : \">\"]));\n        }\n\n        var lastAttrHasTrailingComments = _n.attributes.length && hasTrailingComment(getLast(_n.attributes));\n        var bracketSameLine = // Simple tags (no attributes and no comment in tag name) should be\n        // kept unbroken regardless of `jsxBracketSameLine`\n        !_n.attributes.length && !nameHasComments || options.jsxBracketSameLine && ( // We should print the bracket in a new line for the following cases:\n        // <div\n        //   // comment\n        // >\n        // <div\n        //   attr // comment\n        // >\n        !nameHasComments || _n.attributes.length) && !lastAttrHasTrailingComments; // We should print the opening element expanded if any prop value is a\n        // string literal with newlines\n\n        var _shouldBreak = _n.attributes && _n.attributes.some(function (attr) {\n          return attr.value && isStringLiteral(attr.value) && attr.value.value.includes(\"\\n\");\n        });\n\n        return group(concat([\"<\", path.call(print, \"name\"), path.call(print, \"typeParameters\"), concat([indent(concat(path.map(function (attr) {\n          return concat([line, print(attr)]);\n        }, \"attributes\"))), _n.selfClosing ? line : bracketSameLine ? \">\" : softline]), _n.selfClosing ? \"/>\" : bracketSameLine ? \"\" : \">\"]), {\n          shouldBreak: _shouldBreak\n        });\n      }\n\n    case \"JSXClosingElement\":\n      return concat([\"</\", path.call(print, \"name\"), \">\"]);\n\n    case \"JSXOpeningFragment\":\n    case \"JSXClosingFragment\":\n      {\n        var hasComment = n.comments && n.comments.length;\n        var hasOwnLineComment = hasComment && !n.comments.every(handleComments.isBlockComment);\n        var isOpeningFragment = n.type === \"JSXOpeningFragment\";\n        return concat([isOpeningFragment ? \"<\" : \"</\", indent(concat([hasOwnLineComment ? hardline : hasComment && !isOpeningFragment ? \" \" : \"\", comments.printDanglingComments(path, options, true)])), hasOwnLineComment ? hardline : \"\", \">\"]);\n      }\n\n    case \"JSXText\":\n      /* istanbul ignore next */\n      throw new Error(\"JSXTest should be handled by JSXElement\");\n\n    case \"JSXEmptyExpression\":\n      {\n        var requiresHardline = n.comments && !n.comments.every(handleComments.isBlockComment);\n        return concat([comments.printDanglingComments(path, options,\n        /* sameIndent */\n        !requiresHardline), requiresHardline ? hardline : \"\"]);\n      }\n\n    case \"ClassBody\":\n      if (!n.comments && n.body.length === 0) {\n        return \"{}\";\n      }\n\n      return concat([\"{\", n.body.length > 0 ? indent(concat([hardline, path.call(function (bodyPath) {\n        return printStatementSequence(bodyPath, options, print);\n      }, \"body\")])) : comments.printDanglingComments(path, options), hardline, \"}\"]);\n\n    case \"ClassProperty\":\n    case \"TSAbstractClassProperty\":\n    case \"ClassPrivateProperty\":\n      {\n        if (n.decorators && n.decorators.length !== 0) {\n          parts.push(printDecorators(path, options, print));\n        }\n\n        if (n.accessibility) {\n          parts.push(n.accessibility + \" \");\n        }\n\n        if (n[\"static\"]) {\n          parts.push(\"static \");\n        }\n\n        if (n.type === \"TSAbstractClassProperty\") {\n          parts.push(\"abstract \");\n        }\n\n        if (n.readonly) {\n          parts.push(\"readonly \");\n        }\n\n        var variance = getFlowVariance(n);\n\n        if (variance) {\n          parts.push(variance);\n        }\n\n        if (n.computed) {\n          parts.push(\"[\", path.call(print, \"key\"), \"]\");\n        } else {\n          parts.push(printPropertyKey(path, options, print));\n        }\n\n        parts.push(printOptionalToken(path));\n        parts.push(printTypeAnnotation(path, options, print));\n\n        if (n.value) {\n          parts.push(\" =\", printAssignmentRight(n.key, n.value, path.call(print, \"value\"), options));\n        }\n\n        parts.push(semi);\n        return group(concat(parts));\n      }\n\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n      if (isNodeStartingWithDeclare(n, options)) {\n        parts.push(\"declare \");\n      }\n\n      parts.push(concat(printClass(path, options, print)));\n      return concat(parts);\n\n    case \"TSInterfaceHeritage\":\n      parts.push(path.call(print, \"expression\"));\n\n      if (n.typeParameters) {\n        parts.push(path.call(print, \"typeParameters\"));\n      }\n\n      return concat(parts);\n\n    case \"TemplateElement\":\n      return join(literalline, n.value.raw.split(/\\r?\\n/g));\n\n    case \"TemplateLiteral\":\n      {\n        var expressions = path.map(print, \"expressions\");\n\n        var _parentNode = path.getParentNode();\n\n        if (isJestEachTemplateLiteral(n, _parentNode)) {\n          var _printed2 = printJestEachTemplateLiteral(n, expressions, options);\n\n          if (_printed2) {\n            return _printed2;\n          }\n        }\n\n        var isSimple = isSimpleTemplateLiteral(n);\n\n        if (isSimple) {\n          expressions = expressions.map(function (doc) {\n            return printDocToString(doc, Object.assign({}, options, {\n              printWidth: Infinity\n            })).formatted;\n          });\n        }\n\n        parts.push(lineSuffixBoundary, \"`\");\n        path.each(function (childPath) {\n          var i = childPath.getName();\n          parts.push(print(childPath));\n\n          if (i < expressions.length) {\n            // For a template literal of the following form:\n            //   `someQuery {\n            //     ${call({\n            //       a,\n            //       b,\n            //     })}\n            //   }`\n            // the expression is on its own line (there is a \\n in the previous\n            // quasi literal), therefore we want to indent the JavaScript\n            // expression inside at the beginning of ${ instead of the beginning\n            // of the `.\n            var tabWidth = options.tabWidth;\n            var quasi = childPath.getValue();\n            var indentSize = getIndentSize(quasi.value.raw, tabWidth);\n            var _printed3 = expressions[i];\n\n            if (!isSimple) {\n              // Breaks at the template element boundaries (${ and }) are preferred to breaking\n              // in the middle of a MemberExpression\n              if (n.expressions[i].comments && n.expressions[i].comments.length || n.expressions[i].type === \"MemberExpression\" || n.expressions[i].type === \"OptionalMemberExpression\" || n.expressions[i].type === \"ConditionalExpression\") {\n                _printed3 = concat([indent(concat([softline, _printed3])), softline]);\n              }\n            }\n\n            var aligned = indentSize === 0 && quasi.value.raw.endsWith(\"\\n\") ? align(-Infinity, _printed3) : addAlignmentToDoc(_printed3, indentSize, tabWidth);\n            parts.push(group(concat([\"${\", aligned, lineSuffixBoundary, \"}\"])));\n          }\n        }, \"quasis\");\n        parts.push(\"`\");\n        return concat(parts);\n      }\n    // These types are unprintable because they serve as abstract\n    // supertypes for other (printable) types.\n\n    case \"TaggedTemplateExpression\":\n      return concat([path.call(print, \"tag\"), path.call(print, \"typeParameters\"), path.call(print, \"quasi\")]);\n\n    case \"Node\":\n    case \"Printable\":\n    case \"SourceLocation\":\n    case \"Position\":\n    case \"Statement\":\n    case \"Function\":\n    case \"Pattern\":\n    case \"Expression\":\n    case \"Declaration\":\n    case \"Specifier\":\n    case \"NamedSpecifier\":\n    case \"Comment\":\n    case \"MemberTypeAnnotation\": // Flow\n\n    case \"Type\":\n      /* istanbul ignore next */\n      throw new Error(\"unprintable type: \" + JSON.stringify(n.type));\n    // Type Annotations for Facebook Flow, typically stripped out or\n    // transformed away before printing.\n\n    case \"TypeAnnotation\":\n    case \"TSTypeAnnotation\":\n      if (n.typeAnnotation) {\n        return path.call(print, \"typeAnnotation\");\n      }\n      /* istanbul ignore next */\n\n\n      return \"\";\n\n    case \"TSTupleType\":\n    case \"TupleTypeAnnotation\":\n      {\n        var typesField = n.type === \"TSTupleType\" ? \"elementTypes\" : \"types\";\n        return group(concat([\"[\", indent(concat([softline, printArrayItems(path, options, typesField, print)])), ifBreak(shouldPrintComma(options, \"all\") ? \",\" : \"\"), comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true), softline, \"]\"]));\n      }\n\n    case \"ExistsTypeAnnotation\":\n      return \"*\";\n\n    case \"EmptyTypeAnnotation\":\n      return \"empty\";\n\n    case \"AnyTypeAnnotation\":\n      return \"any\";\n\n    case \"MixedTypeAnnotation\":\n      return \"mixed\";\n\n    case \"ArrayTypeAnnotation\":\n      return concat([path.call(print, \"elementType\"), \"[]\"]);\n\n    case \"BooleanTypeAnnotation\":\n      return \"boolean\";\n\n    case \"BooleanLiteralTypeAnnotation\":\n      return \"\" + n.value;\n\n    case \"DeclareClass\":\n      return printFlowDeclaration(path, printClass(path, options, print));\n\n    case \"TSDeclareFunction\":\n      // For TypeScript the TSDeclareFunction node shares the AST\n      // structure with FunctionDeclaration\n      return concat([n.declare ? \"declare \" : \"\", printFunctionDeclaration(path, print, options), semi]);\n\n    case \"DeclareFunction\":\n      return printFlowDeclaration(path, [\"function \", path.call(print, \"id\"), n.predicate ? \" \" : \"\", path.call(print, \"predicate\"), semi]);\n\n    case \"DeclareModule\":\n      return printFlowDeclaration(path, [\"module \", path.call(print, \"id\"), \" \", path.call(print, \"body\")]);\n\n    case \"DeclareModuleExports\":\n      return printFlowDeclaration(path, [\"module.exports\", \": \", path.call(print, \"typeAnnotation\"), semi]);\n\n    case \"DeclareVariable\":\n      return printFlowDeclaration(path, [\"var \", path.call(print, \"id\"), semi]);\n\n    case \"DeclareExportAllDeclaration\":\n      return concat([\"declare export * from \", path.call(print, \"source\")]);\n\n    case \"DeclareExportDeclaration\":\n      return concat([\"declare \", printExportDeclaration(path, options, print)]);\n\n    case \"DeclareOpaqueType\":\n    case \"OpaqueType\":\n      {\n        parts.push(\"opaque type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"));\n\n        if (n.supertype) {\n          parts.push(\": \", path.call(print, \"supertype\"));\n        }\n\n        if (n.impltype) {\n          parts.push(\" = \", path.call(print, \"impltype\"));\n        }\n\n        parts.push(semi);\n\n        if (n.type === \"DeclareOpaqueType\") {\n          return printFlowDeclaration(path, parts);\n        }\n\n        return concat(parts);\n      }\n\n    case \"FunctionTypeAnnotation\":\n    case \"TSFunctionType\":\n      {\n        // FunctionTypeAnnotation is ambiguous:\n        // declare function foo(a: B): void; OR\n        // var A: (a: B) => void;\n        var _parent7 = path.getParentNode(0);\n\n        var _parentParent2 = path.getParentNode(1);\n\n        var _parentParentParent = path.getParentNode(2);\n\n        var isArrowFunctionTypeAnnotation = n.type === \"TSFunctionType\" || !((_parent7.type === \"ObjectTypeProperty\" || _parent7.type === \"ObjectTypeInternalSlot\") && !getFlowVariance(_parent7) && !_parent7.optional && options.locStart(_parent7) === options.locStart(n) || _parent7.type === \"ObjectTypeCallProperty\" || _parentParentParent && _parentParentParent.type === \"DeclareFunction\");\n        var needsColon = isArrowFunctionTypeAnnotation && (_parent7.type === \"TypeAnnotation\" || _parent7.type === \"TSTypeAnnotation\"); // Sadly we can't put it inside of FastPath::needsColon because we are\n        // printing \":\" as part of the expression and it would put parenthesis\n        // around :(\n\n        var needsParens = needsColon && isArrowFunctionTypeAnnotation && (_parent7.type === \"TypeAnnotation\" || _parent7.type === \"TSTypeAnnotation\") && _parentParent2.type === \"ArrowFunctionExpression\";\n\n        if (isObjectTypePropertyAFunction(_parent7, options)) {\n          isArrowFunctionTypeAnnotation = true;\n          needsColon = true;\n        }\n\n        if (needsParens) {\n          parts.push(\"(\");\n        }\n\n        parts.push(printFunctionParams(path, print, options,\n        /* expandArg */\n        false,\n        /* printTypeParams */\n        true)); // The returnType is not wrapped in a TypeAnnotation, so the colon\n        // needs to be added separately.\n\n        if (n.returnType || n.predicate || n.typeAnnotation) {\n          parts.push(isArrowFunctionTypeAnnotation ? \" => \" : \": \", path.call(print, \"returnType\"), path.call(print, \"predicate\"), path.call(print, \"typeAnnotation\"));\n        }\n\n        if (needsParens) {\n          parts.push(\")\");\n        }\n\n        return group(concat(parts));\n      }\n\n    case \"TSRestType\":\n      return concat([\"...\", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSOptionalType\":\n      return concat([path.call(print, \"typeAnnotation\"), \"?\"]);\n\n    case \"FunctionTypeParam\":\n      return concat([path.call(print, \"name\"), printOptionalToken(path), n.name ? \": \" : \"\", path.call(print, \"typeAnnotation\")]);\n\n    case \"GenericTypeAnnotation\":\n      return concat([path.call(print, \"id\"), path.call(print, \"typeParameters\")]);\n\n    case \"DeclareInterface\":\n    case \"InterfaceDeclaration\":\n    case \"InterfaceTypeAnnotation\":\n      {\n        if (n.type === \"DeclareInterface\" || isNodeStartingWithDeclare(n, options)) {\n          parts.push(\"declare \");\n        }\n\n        parts.push(\"interface\");\n\n        if (n.type === \"DeclareInterface\" || n.type === \"InterfaceDeclaration\") {\n          parts.push(\" \", path.call(print, \"id\"), path.call(print, \"typeParameters\"));\n        }\n\n        if (n[\"extends\"].length > 0) {\n          parts.push(group(indent(concat([line, \"extends \", (n[\"extends\"].length === 1 ? identity : indent)(join(concat([\",\", line]), path.map(print, \"extends\")))]))));\n        }\n\n        parts.push(\" \", path.call(print, \"body\"));\n        return group(concat(parts));\n      }\n\n    case \"ClassImplements\":\n    case \"InterfaceExtends\":\n      return concat([path.call(print, \"id\"), path.call(print, \"typeParameters\")]);\n\n    case \"TSClassImplements\":\n      return concat([path.call(print, \"expression\"), path.call(print, \"typeParameters\")]);\n\n    case \"TSIntersectionType\":\n    case \"IntersectionTypeAnnotation\":\n      {\n        var types = path.map(print, \"types\");\n        var result = [];\n        var wasIndented = false;\n\n        for (var _i = 0; _i < types.length; ++_i) {\n          if (_i === 0) {\n            result.push(types[_i]);\n          } else if (isObjectType(n.types[_i - 1]) && isObjectType(n.types[_i])) {\n            // If both are objects, don't indent\n            result.push(concat([\" & \", wasIndented ? indent(types[_i]) : types[_i]]));\n          } else if (!isObjectType(n.types[_i - 1]) && !isObjectType(n.types[_i])) {\n            // If no object is involved, go to the next line if it breaks\n            result.push(indent(concat([\" &\", line, types[_i]])));\n          } else {\n            // If you go from object to non-object or vis-versa, then inline it\n            if (_i > 1) {\n              wasIndented = true;\n            }\n\n            result.push(\" & \", _i > 1 ? indent(types[_i]) : types[_i]);\n          }\n        }\n\n        return group(concat(result));\n      }\n\n    case \"TSUnionType\":\n    case \"UnionTypeAnnotation\":\n      {\n        // single-line variation\n        // A | B | C\n        // multi-line variation\n        // | A\n        // | B\n        // | C\n        var _parent8 = path.getParentNode(); // If there's a leading comment, the parent is doing the indentation\n\n\n        var shouldIndent = _parent8.type !== \"TypeParameterInstantiation\" && _parent8.type !== \"TSTypeParameterInstantiation\" && _parent8.type !== \"GenericTypeAnnotation\" && _parent8.type !== \"TSTypeReference\" && _parent8.type !== \"TSTypeAssertion\" && !(_parent8.type === \"FunctionTypeParam\" && !_parent8.name) && !((_parent8.type === \"TypeAlias\" || _parent8.type === \"VariableDeclarator\" || _parent8.type === \"TSTypeAliasDeclaration\") && hasLeadingOwnLineComment(options.originalText, n, options)); // {\n        //   a: string\n        // } | null | void\n        // should be inlined and not be printed in the multi-line variant\n\n        var shouldHug = shouldHugType(n); // We want to align the children but without its comment, so it looks like\n        // | child1\n        // // comment\n        // | child2\n\n        var _printed4 = path.map(function (typePath) {\n          var printedType = typePath.call(print);\n\n          if (!shouldHug) {\n            printedType = align(2, printedType);\n          }\n\n          return comments.printComments(typePath, function () {\n            return printedType;\n          }, options);\n        }, \"types\");\n\n        if (shouldHug) {\n          return join(\" | \", _printed4);\n        }\n\n        var shouldAddStartLine = shouldIndent && !hasLeadingOwnLineComment(options.originalText, n, options);\n        var code = concat([ifBreak(concat([shouldAddStartLine ? line : \"\", \"| \"])), join(concat([line, \"| \"]), _printed4)]);\n        var hasParens;\n\n        if (n.type === \"TSUnionType\") {\n          var _grandParent = path.getNode(2);\n\n          var greatGrandParent = path.getParentNode(2);\n          var greatGreatGrandParent = path.getParentNode(3);\n          hasParens = _parent8.type === \"TSParenthesizedType\" && (_grandParent.type === \"TSAsExpression\" || _grandParent.type === \"TSUnionType\" || _grandParent.type === \"TSIntersectionType\" || _grandParent.type === \"TSTypeOperator\" || _grandParent.type === \"TSArrayType\") || greatGrandParent && greatGrandParent.type === \"TSParenthesizedType\" && greatGreatGrandParent && (greatGreatGrandParent.type === \"TSUnionType\" || greatGreatGrandParent.type === \"TSIntersectionType\");\n        } else {\n          hasParens = pathNeedsParens(path, options);\n        }\n\n        if (hasParens) {\n          return group(concat([indent(code), softline]));\n        }\n\n        return group(shouldIndent ? indent(code) : code);\n      }\n\n    case \"NullableTypeAnnotation\":\n      return concat([\"?\", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSNullKeyword\":\n    case \"NullLiteralTypeAnnotation\":\n      return \"null\";\n\n    case \"ThisTypeAnnotation\":\n      return \"this\";\n\n    case \"NumberTypeAnnotation\":\n      return \"number\";\n\n    case \"ObjectTypeCallProperty\":\n      if (n[\"static\"]) {\n        parts.push(\"static \");\n      }\n\n      parts.push(path.call(print, \"value\"));\n      return concat(parts);\n\n    case \"ObjectTypeIndexer\":\n      {\n        var _variance = getFlowVariance(n);\n\n        return concat([_variance || \"\", \"[\", path.call(print, \"id\"), n.id ? \": \" : \"\", path.call(print, \"key\"), \"]: \", path.call(print, \"value\")]);\n      }\n\n    case \"ObjectTypeProperty\":\n      {\n        var _variance2 = getFlowVariance(n);\n\n        var modifier = \"\";\n\n        if (n.proto) {\n          modifier = \"proto \";\n        } else if (n[\"static\"]) {\n          modifier = \"static \";\n        }\n\n        return concat([modifier, isGetterOrSetter(n) ? n.kind + \" \" : \"\", _variance2 || \"\", printPropertyKey(path, options, print), printOptionalToken(path), isFunctionNotation(n, options) ? \"\" : \": \", path.call(print, \"value\")]);\n      }\n\n    case \"QualifiedTypeIdentifier\":\n      return concat([path.call(print, \"qualification\"), \".\", path.call(print, \"id\")]);\n\n    case \"StringLiteralTypeAnnotation\":\n      return nodeStr(n, options);\n\n    case \"NumberLiteralTypeAnnotation\":\n      assert.strictEqual(_typeof(n.value), \"number\");\n\n      if (n.extra != null) {\n        return printNumber(n.extra.raw);\n      }\n\n      return printNumber(n.raw);\n\n    case \"StringTypeAnnotation\":\n      return \"string\";\n\n    case \"DeclareTypeAlias\":\n    case \"TypeAlias\":\n      {\n        if (n.type === \"DeclareTypeAlias\" || isNodeStartingWithDeclare(n, options)) {\n          parts.push(\"declare \");\n        }\n\n        var _printed5 = printAssignmentRight(n.id, n.right, path.call(print, \"right\"), options);\n\n        parts.push(\"type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"), \" =\", _printed5, semi);\n        return group(concat(parts));\n      }\n\n    case \"TypeCastExpression\":\n      {\n        var value = path.getValue(); // Flow supports a comment syntax for specifying type annotations: https://flow.org/en/docs/types/comments/.\n        // Unfortunately, its parser doesn't differentiate between comment annotations and regular\n        // annotations when producing an AST. So to preserve parentheses around type casts that use\n        // the comment syntax, we need to hackily read the source itself to see if the code contains\n        // a type annotation comment.\n        //\n        // Note that we're able to use the normal whitespace regex here because the Flow parser has\n        // already deemed this AST node to be a type cast. Only the Babel parser needs the\n        // non-line-break whitespace regex, which is why hasFlowShorthandAnnotationComment() is\n        // implemented differently.\n\n        var commentSyntax = value && value.typeAnnotation && value.typeAnnotation.range && options.originalText.substring(value.typeAnnotation.range[0]).match(/^\\/\\*\\s*:/);\n        return concat([\"(\", path.call(print, \"expression\"), commentSyntax ? \" /*\" : \"\", \": \", path.call(print, \"typeAnnotation\"), commentSyntax ? \" */\" : \"\", \")\"]);\n      }\n\n    case \"TypeParameterDeclaration\":\n    case \"TypeParameterInstantiation\":\n      {\n        var _value = path.getValue();\n\n        var commentStart = _value.range ? options.originalText.substring(0, _value.range[0]).lastIndexOf(\"/*\") : -1; // As noted in the TypeCastExpression comments above, we're able to use a normal whitespace regex here\n        // because we know for sure that this is a type definition.\n\n        var _commentSyntax = commentStart >= 0 && options.originalText.substring(commentStart).match(/^\\/\\*\\s*::/);\n\n        if (_commentSyntax) {\n          return concat([\"/*:: \", printTypeParameters(path, options, print, \"params\"), \" */\"]);\n        }\n\n        return printTypeParameters(path, options, print, \"params\");\n      }\n\n    case \"TSTypeParameterDeclaration\":\n    case \"TSTypeParameterInstantiation\":\n      return printTypeParameters(path, options, print, \"params\");\n\n    case \"TSTypeParameter\":\n    case \"TypeParameter\":\n      {\n        var _parent9 = path.getParentNode();\n\n        if (_parent9.type === \"TSMappedType\") {\n          parts.push(\"[\", path.call(print, \"name\"));\n\n          if (n.constraint) {\n            parts.push(\" in \", path.call(print, \"constraint\"));\n          }\n\n          parts.push(\"]\");\n          return concat(parts);\n        }\n\n        var _variance3 = getFlowVariance(n);\n\n        if (_variance3) {\n          parts.push(_variance3);\n        }\n\n        parts.push(path.call(print, \"name\"));\n\n        if (n.bound) {\n          parts.push(\": \");\n          parts.push(path.call(print, \"bound\"));\n        }\n\n        if (n.constraint) {\n          parts.push(\" extends \", path.call(print, \"constraint\"));\n        }\n\n        if (n[\"default\"]) {\n          parts.push(\" = \", path.call(print, \"default\"));\n        } // Keep comma if the file extension is .tsx and\n        // has one type parameter that isn't extend with any types.\n        // Because, otherwise formatted result will be invalid as tsx.\n\n\n        var _grandParent2 = path.getNode(2);\n\n        if (_parent9.params && _parent9.params.length === 1 && options.filepath && /\\.tsx$/i.test(options.filepath) && !n.constraint && _grandParent2.type === \"ArrowFunctionExpression\") {\n          parts.push(\",\");\n        }\n\n        return concat(parts);\n      }\n\n    case \"TypeofTypeAnnotation\":\n      return concat([\"typeof \", path.call(print, \"argument\")]);\n\n    case \"VoidTypeAnnotation\":\n      return \"void\";\n\n    case \"InferredPredicate\":\n      return \"%checks\";\n    // Unhandled types below. If encountered, nodes of these types should\n    // be either left alone or desugared into AST types that are fully\n    // supported by the pretty-printer.\n\n    case \"DeclaredPredicate\":\n      return concat([\"%checks(\", path.call(print, \"value\"), \")\"]);\n\n    case \"TSAbstractKeyword\":\n      return \"abstract\";\n\n    case \"TSAnyKeyword\":\n      return \"any\";\n\n    case \"TSAsyncKeyword\":\n      return \"async\";\n\n    case \"TSBooleanKeyword\":\n      return \"boolean\";\n\n    case \"TSBigIntKeyword\":\n      return \"bigint\";\n\n    case \"TSConstKeyword\":\n      return \"const\";\n\n    case \"TSDeclareKeyword\":\n      return \"declare\";\n\n    case \"TSExportKeyword\":\n      return \"export\";\n\n    case \"TSNeverKeyword\":\n      return \"never\";\n\n    case \"TSNumberKeyword\":\n      return \"number\";\n\n    case \"TSObjectKeyword\":\n      return \"object\";\n\n    case \"TSProtectedKeyword\":\n      return \"protected\";\n\n    case \"TSPrivateKeyword\":\n      return \"private\";\n\n    case \"TSPublicKeyword\":\n      return \"public\";\n\n    case \"TSReadonlyKeyword\":\n      return \"readonly\";\n\n    case \"TSSymbolKeyword\":\n      return \"symbol\";\n\n    case \"TSStaticKeyword\":\n      return \"static\";\n\n    case \"TSStringKeyword\":\n      return \"string\";\n\n    case \"TSUndefinedKeyword\":\n      return \"undefined\";\n\n    case \"TSUnknownKeyword\":\n      return \"unknown\";\n\n    case \"TSVoidKeyword\":\n      return \"void\";\n\n    case \"TSAsExpression\":\n      return concat([path.call(print, \"expression\"), \" as \", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSArrayType\":\n      return concat([path.call(print, \"elementType\"), \"[]\"]);\n\n    case \"TSPropertySignature\":\n      {\n        if (n[\"export\"]) {\n          parts.push(\"export \");\n        }\n\n        if (n.accessibility) {\n          parts.push(n.accessibility + \" \");\n        }\n\n        if (n[\"static\"]) {\n          parts.push(\"static \");\n        }\n\n        if (n.readonly) {\n          parts.push(\"readonly \");\n        }\n\n        if (n.computed) {\n          parts.push(\"[\");\n        }\n\n        parts.push(printPropertyKey(path, options, print));\n\n        if (n.computed) {\n          parts.push(\"]\");\n        }\n\n        parts.push(printOptionalToken(path));\n\n        if (n.typeAnnotation) {\n          parts.push(\": \");\n          parts.push(path.call(print, \"typeAnnotation\"));\n        } // This isn't valid semantically, but it's in the AST so we can print it.\n\n\n        if (n.initializer) {\n          parts.push(\" = \", path.call(print, \"initializer\"));\n        }\n\n        return concat(parts);\n      }\n\n    case \"TSParameterProperty\":\n      if (n.accessibility) {\n        parts.push(n.accessibility + \" \");\n      }\n\n      if (n[\"export\"]) {\n        parts.push(\"export \");\n      }\n\n      if (n[\"static\"]) {\n        parts.push(\"static \");\n      }\n\n      if (n.readonly) {\n        parts.push(\"readonly \");\n      }\n\n      parts.push(path.call(print, \"parameter\"));\n      return concat(parts);\n\n    case \"TSTypeReference\":\n      return concat([path.call(print, \"typeName\"), printTypeParameters(path, options, print, \"typeParameters\")]);\n\n    case \"TSTypeQuery\":\n      return concat([\"typeof \", path.call(print, \"exprName\")]);\n\n    case \"TSParenthesizedType\":\n      {\n        return path.call(print, \"typeAnnotation\");\n      }\n\n    case \"TSIndexSignature\":\n      {\n        var _parent10 = path.getParentNode();\n\n        return concat([n[\"export\"] ? \"export \" : \"\", n.accessibility ? concat([n.accessibility, \" \"]) : \"\", n[\"static\"] ? \"static \" : \"\", n.readonly ? \"readonly \" : \"\", \"[\", n.parameters ? concat(path.map(print, \"parameters\")) : \"\", \"]: \", path.call(print, \"typeAnnotation\"), _parent10.type === \"ClassBody\" ? semi : \"\"]);\n      }\n\n    case \"TSTypePredicate\":\n      return concat([path.call(print, \"parameterName\"), \" is \", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSNonNullExpression\":\n      return concat([path.call(print, \"expression\"), \"!\"]);\n\n    case \"TSThisType\":\n      return \"this\";\n\n    case \"TSImportType\":\n      return concat([!n.isTypeOf ? \"\" : \"typeof \", \"import(\", path.call(print, \"parameter\"), \")\", !n.qualifier ? \"\" : concat([\".\", path.call(print, \"qualifier\")]), printTypeParameters(path, options, print, \"typeParameters\")]);\n\n    case \"TSLiteralType\":\n      return path.call(print, \"literal\");\n\n    case \"TSIndexedAccessType\":\n      return concat([path.call(print, \"objectType\"), \"[\", path.call(print, \"indexType\"), \"]\"]);\n\n    case \"TSConstructSignatureDeclaration\":\n    case \"TSCallSignatureDeclaration\":\n    case \"TSConstructorType\":\n      {\n        if (n.type !== \"TSCallSignatureDeclaration\") {\n          parts.push(\"new \");\n        }\n\n        parts.push(group(printFunctionParams(path, print, options,\n        /* expandArg */\n        false,\n        /* printTypeParams */\n        true)));\n\n        if (n.returnType) {\n          var isType = n.type === \"TSConstructorType\";\n          parts.push(isType ? \" => \" : \": \", path.call(print, \"returnType\"));\n        }\n\n        return concat(parts);\n      }\n\n    case \"TSTypeOperator\":\n      return concat([n.operator, \" \", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSMappedType\":\n      {\n        var _shouldBreak2 = hasNewlineInRange(options.originalText, options.locStart(n), options.locEnd(n));\n\n        return group(concat([\"{\", indent(concat([options.bracketSpacing ? line : softline, n.readonly ? concat([getTypeScriptMappedTypeModifier(n.readonly, \"readonly\"), \" \"]) : \"\", printTypeScriptModifiers(path, options, print), path.call(print, \"typeParameter\"), n.optional ? getTypeScriptMappedTypeModifier(n.optional, \"?\") : \"\", \": \", path.call(print, \"typeAnnotation\"), ifBreak(semi, \"\")])), comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true), options.bracketSpacing ? line : softline, \"}\"]), {\n          shouldBreak: _shouldBreak2\n        });\n      }\n\n    case \"TSMethodSignature\":\n      parts.push(n.accessibility ? concat([n.accessibility, \" \"]) : \"\", n[\"export\"] ? \"export \" : \"\", n[\"static\"] ? \"static \" : \"\", n.readonly ? \"readonly \" : \"\", n.computed ? \"[\" : \"\", path.call(print, \"key\"), n.computed ? \"]\" : \"\", printOptionalToken(path), printFunctionParams(path, print, options,\n      /* expandArg */\n      false,\n      /* printTypeParams */\n      true));\n\n      if (n.returnType) {\n        parts.push(\": \", path.call(print, \"returnType\"));\n      }\n\n      return group(concat(parts));\n\n    case \"TSNamespaceExportDeclaration\":\n      parts.push(\"export as namespace \", path.call(print, \"id\"));\n\n      if (options.semi) {\n        parts.push(\";\");\n      }\n\n      return group(concat(parts));\n\n    case \"TSEnumDeclaration\":\n      if (isNodeStartingWithDeclare(n, options)) {\n        parts.push(\"declare \");\n      }\n\n      if (n.modifiers) {\n        parts.push(printTypeScriptModifiers(path, options, print));\n      }\n\n      if (n[\"const\"]) {\n        parts.push(\"const \");\n      }\n\n      parts.push(\"enum \", path.call(print, \"id\"), \" \");\n\n      if (n.members.length === 0) {\n        parts.push(group(concat([\"{\", comments.printDanglingComments(path, options), softline, \"}\"])));\n      } else {\n        parts.push(group(concat([\"{\", indent(concat([hardline, printArrayItems(path, options, \"members\", print), shouldPrintComma(options, \"es5\") ? \",\" : \"\"])), comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true), hardline, \"}\"])));\n      }\n\n      return concat(parts);\n\n    case \"TSEnumMember\":\n      parts.push(path.call(print, \"id\"));\n\n      if (n.initializer) {\n        parts.push(\" = \", path.call(print, \"initializer\"));\n      }\n\n      return concat(parts);\n\n    case \"TSImportEqualsDeclaration\":\n      if (n.isExport) {\n        parts.push(\"export \");\n      }\n\n      parts.push(\"import \", path.call(print, \"id\"), \" = \", path.call(print, \"moduleReference\"));\n\n      if (options.semi) {\n        parts.push(\";\");\n      }\n\n      return group(concat(parts));\n\n    case \"TSExternalModuleReference\":\n      return concat([\"require(\", path.call(print, \"expression\"), \")\"]);\n\n    case \"TSModuleDeclaration\":\n      {\n        var _parent11 = path.getParentNode();\n\n        var isExternalModule = isLiteral(n.id);\n        var parentIsDeclaration = _parent11.type === \"TSModuleDeclaration\";\n        var bodyIsDeclaration = n.body && n.body.type === \"TSModuleDeclaration\";\n\n        if (parentIsDeclaration) {\n          parts.push(\".\");\n        } else {\n          if (n.declare === true) {\n            parts.push(\"declare \");\n          }\n\n          parts.push(printTypeScriptModifiers(path, options, print));\n          var textBetweenNodeAndItsId = options.originalText.slice(options.locStart(n), options.locStart(n.id)); // Global declaration looks like this:\n          // (declare)? global { ... }\n\n          var isGlobalDeclaration = n.id.type === \"Identifier\" && n.id.name === \"global\" && !/namespace|module/.test(textBetweenNodeAndItsId);\n\n          if (!isGlobalDeclaration) {\n            parts.push(isExternalModule || /(^|\\s)module(\\s|$)/.test(textBetweenNodeAndItsId) ? \"module \" : \"namespace \");\n          }\n        }\n\n        parts.push(path.call(print, \"id\"));\n\n        if (bodyIsDeclaration) {\n          parts.push(path.call(print, \"body\"));\n        } else if (n.body) {\n          parts.push(\" \", group(path.call(print, \"body\")));\n        } else {\n          parts.push(semi);\n        }\n\n        return concat(parts);\n      }\n\n    case \"PrivateName\":\n      return concat([\"#\", path.call(print, \"id\")]);\n\n    case \"TSConditionalType\":\n      return printTernaryOperator(path, options, print, {\n        beforeParts: function beforeParts() {\n          return [path.call(print, \"checkType\"), \" \", \"extends\", \" \", path.call(print, \"extendsType\")];\n        },\n        afterParts: function afterParts() {\n          return [];\n        },\n        shouldCheckJsx: false,\n        conditionalNodeType: \"TSConditionalType\",\n        consequentNodePropertyName: \"trueType\",\n        alternateNodePropertyName: \"falseType\",\n        testNodePropertyName: \"checkType\",\n        breakNested: true\n      });\n\n    case \"TSInferType\":\n      return concat([\"infer\", \" \", path.call(print, \"typeParameter\")]);\n\n    case \"InterpreterDirective\":\n      parts.push(\"#!\", n.value, hardline);\n\n      if (isNextLineEmpty(options.originalText, n, options)) {\n        parts.push(hardline);\n      }\n\n      return concat(parts);\n\n    case \"NGRoot\":\n      return concat([].concat(path.call(print, \"node\"), !n.node.comments || n.node.comments.length === 0 ? [] : concat([\" //\", n.node.comments[0].value.trimRight()])));\n\n    case \"NGChainedExpression\":\n      return group(join(concat([\";\", line]), path.map(function (childPath) {\n        return hasNgSideEffect(childPath) ? print(childPath) : concat([\"(\", print(childPath), \")\"]);\n      }, \"expressions\")));\n\n    case \"NGEmptyExpression\":\n      return \"\";\n\n    case \"NGQuotedExpression\":\n      return concat([n.prefix, \":\", n.value]);\n\n    case \"NGMicrosyntax\":\n      return concat(path.map(function (childPath, index) {\n        return concat([index === 0 ? \"\" : isNgForOf(childPath.getValue(), index, n) ? \" \" : concat([\";\", line]), print(childPath)]);\n      }, \"body\"));\n\n    case \"NGMicrosyntaxKey\":\n      return /^[a-z_$][a-z0-9_$]*(-[a-z_$][a-z0-9_$])*$/i.test(n.name) ? n.name : JSON.stringify(n.name);\n\n    case \"NGMicrosyntaxExpression\":\n      return concat([path.call(print, \"expression\"), n.alias === null ? \"\" : concat([\" as \", path.call(print, \"alias\")])]);\n\n    case \"NGMicrosyntaxKeyedExpression\":\n      {\n        var index = path.getName();\n\n        var _parentNode2 = path.getParentNode();\n\n        var shouldNotPrintColon = isNgForOf(n, index, _parentNode2) || (index === 1 && (n.key.name === \"then\" || n.key.name === \"else\") || index === 2 && n.key.name === \"else\" && _parentNode2.body[index - 1].type === \"NGMicrosyntaxKeyedExpression\" && _parentNode2.body[index - 1].key.name === \"then\") && _parentNode2.body[0].type === \"NGMicrosyntaxExpression\";\n        return concat([path.call(print, \"key\"), shouldNotPrintColon ? \" \" : \": \", path.call(print, \"expression\")]);\n      }\n\n    case \"NGMicrosyntaxLet\":\n      return concat([\"let \", path.call(print, \"key\"), n.value === null ? \"\" : concat([\" = \", path.call(print, \"value\")])]);\n\n    case \"NGMicrosyntaxAs\":\n      return concat([path.call(print, \"key\"), \" as \", path.call(print, \"alias\")]);\n\n    default:\n      /* istanbul ignore next */\n      throw new Error(\"unknown type: \" + JSON.stringify(n.type));\n  }\n}\n\nfunction isNgForOf(node, index, parentNode) {\n  return node.type === \"NGMicrosyntaxKeyedExpression\" && node.key.name === \"of\" && index === 1 && parentNode.body[0].type === \"NGMicrosyntaxLet\" && parentNode.body[0].value === null;\n}\n/** identify if an angular expression seems to have side effects */\n\n\nfunction hasNgSideEffect(path) {\n  return hasNode(path.getValue(), function (node) {\n    switch (node.type) {\n      case undefined:\n        return false;\n\n      case \"CallExpression\":\n      case \"OptionalCallExpression\":\n      case \"AssignmentExpression\":\n        return true;\n    }\n  });\n}\n\nfunction printStatementSequence(path, options, print) {\n  var printed = [];\n  var bodyNode = path.getNode();\n  var isClass = bodyNode.type === \"ClassBody\";\n  path.map(function (stmtPath, i) {\n    var stmt = stmtPath.getValue(); // Just in case the AST has been modified to contain falsy\n    // \"statements,\" it's safer simply to skip them.\n\n    /* istanbul ignore if */\n\n    if (!stmt) {\n      return;\n    } // Skip printing EmptyStatement nodes to avoid leaving stray\n    // semicolons lying around.\n\n\n    if (stmt.type === \"EmptyStatement\") {\n      return;\n    }\n\n    var stmtPrinted = print(stmtPath);\n    var text = options.originalText;\n    var parts = []; // in no-semi mode, prepend statement with semicolon if it might break ASI\n    // don't prepend the only JSX element in a program with semicolon\n\n    if (!options.semi && !isClass && !isTheOnlyJSXElementInMarkdown(options, stmtPath) && stmtNeedsASIProtection(stmtPath, options)) {\n      if (stmt.comments && stmt.comments.some(function (comment) {\n        return comment.leading;\n      })) {\n        parts.push(print(stmtPath, {\n          needsSemi: true\n        }));\n      } else {\n        parts.push(\";\", stmtPrinted);\n      }\n    } else {\n      parts.push(stmtPrinted);\n    }\n\n    if (!options.semi && isClass) {\n      if (classPropMayCauseASIProblems(stmtPath)) {\n        parts.push(\";\");\n      } else if (stmt.type === \"ClassProperty\") {\n        var nextChild = bodyNode.body[i + 1];\n\n        if (classChildNeedsASIProtection(nextChild)) {\n          parts.push(\";\");\n        }\n      }\n    }\n\n    if (isNextLineEmpty(text, stmt, options) && !isLastStatement(stmtPath)) {\n      parts.push(hardline);\n    }\n\n    printed.push(concat(parts));\n  });\n  return join(hardline, printed);\n}\n\nfunction printPropertyKey(path, options, print) {\n  var node = path.getNode();\n  var parent = path.getParentNode();\n  var key = node.key;\n\n  if (options.quoteProps === \"consistent\" && !needsQuoteProps.has(parent)) {\n    var objectHasStringProp = (parent.properties || parent.body || parent.members).some(function (prop) {\n      return !prop.computed && prop.key && isStringLiteral(prop.key) && !isStringPropSafeToCoerceToIdentifier(prop, options);\n    });\n    needsQuoteProps.set(parent, objectHasStringProp);\n  }\n\n  if (key.type === \"Identifier\" && !node.computed && (options.parser === \"json\" || options.quoteProps === \"consistent\" && needsQuoteProps.get(parent))) {\n    // a -> \"a\"\n    var prop = printString(JSON.stringify(key.name), options);\n    return path.call(function (keyPath) {\n      return comments.printComments(keyPath, function () {\n        return prop;\n      }, options);\n    }, \"key\");\n  }\n\n  if (!node.computed && isStringPropSafeToCoerceToIdentifier(node, options) && (options.quoteProps === \"as-needed\" || options.quoteProps === \"consistent\" && !needsQuoteProps.get(parent))) {\n    // 'a' -> a\n    return path.call(function (keyPath) {\n      return comments.printComments(keyPath, function () {\n        return key.value;\n      }, options);\n    }, \"key\");\n  }\n\n  return path.call(print, \"key\");\n}\n\nfunction printMethod(path, options, print) {\n  var node = path.getNode();\n  var semi = options.semi ? \";\" : \"\";\n  var kind = node.kind;\n  var parts = [];\n\n  if (node.type === \"ObjectMethod\" || node.type === \"ClassMethod\" || node.type === \"ClassPrivateMethod\") {\n    node.value = node;\n  }\n\n  if (node.value.async) {\n    parts.push(\"async \");\n  }\n\n  if (!kind || kind === \"init\" || kind === \"method\" || kind === \"constructor\") {\n    if (node.value.generator) {\n      parts.push(\"*\");\n    }\n  } else {\n    assert.ok(kind === \"get\" || kind === \"set\");\n    parts.push(kind, \" \");\n  }\n\n  var key = printPropertyKey(path, options, print);\n\n  if (node.computed) {\n    key = concat([\"[\", key, \"]\"]);\n  }\n\n  parts.push(key, concat(path.call(function (valuePath) {\n    return [printFunctionTypeParameters(valuePath, options, print), group(concat([printFunctionParams(valuePath, print, options), printReturnType(valuePath, print, options)]))];\n  }, \"value\")));\n\n  if (!node.value.body || node.value.body.length === 0) {\n    parts.push(semi);\n  } else {\n    parts.push(\" \", path.call(print, \"value\", \"body\"));\n  }\n\n  return concat(parts);\n}\n\nfunction couldGroupArg(arg) {\n  return arg.type === \"ObjectExpression\" && (arg.properties.length > 0 || arg.comments) || arg.type === \"ArrayExpression\" && (arg.elements.length > 0 || arg.comments) || arg.type === \"TSTypeAssertion\" || arg.type === \"TSAsExpression\" || arg.type === \"FunctionExpression\" || arg.type === \"ArrowFunctionExpression\" && ( // we want to avoid breaking inside composite return types but not simple keywords\n  // https://github.com/prettier/prettier/issues/4070\n  // export class Thing implements OtherThing {\n  //   do: (type: Type) => Provider<Prop> = memoize(\n  //     (type: ObjectType): Provider<Opts> => {}\n  //   );\n  // }\n  // https://github.com/prettier/prettier/issues/6099\n  // app.get(\"/\", (req, res): void => {\n  //   res.send(\"Hello World!\");\n  // });\n  !arg.returnType || !arg.returnType.typeAnnotation || arg.returnType.typeAnnotation.type !== \"TSTypeReference\") && (arg.body.type === \"BlockStatement\" || arg.body.type === \"ArrowFunctionExpression\" || arg.body.type === \"ObjectExpression\" || arg.body.type === \"ArrayExpression\" || arg.body.type === \"CallExpression\" || arg.body.type === \"OptionalCallExpression\" || arg.body.type === \"ConditionalExpression\" || isJSXNode(arg.body));\n}\n\nfunction shouldGroupLastArg(args) {\n  var lastArg = getLast(args);\n  var penultimateArg = getPenultimate(args);\n  return !hasLeadingComment(lastArg) && !hasTrailingComment(lastArg) && couldGroupArg(lastArg) && ( // If the last two arguments are of the same type,\n  // disable last element expansion.\n  !penultimateArg || penultimateArg.type !== lastArg.type);\n}\n\nfunction shouldGroupFirstArg(args) {\n  if (args.length !== 2) {\n    return false;\n  }\n\n  var firstArg = args[0];\n  var secondArg = args[1];\n  return (!firstArg.comments || !firstArg.comments.length) && (firstArg.type === \"FunctionExpression\" || firstArg.type === \"ArrowFunctionExpression\" && firstArg.body.type === \"BlockStatement\") && secondArg.type !== \"FunctionExpression\" && secondArg.type !== \"ArrowFunctionExpression\" && secondArg.type !== \"ConditionalExpression\" && !couldGroupArg(secondArg);\n}\n\nfunction isSimpleFlowType(node) {\n  var flowTypeAnnotations = [\"AnyTypeAnnotation\", \"NullLiteralTypeAnnotation\", \"GenericTypeAnnotation\", \"ThisTypeAnnotation\", \"NumberTypeAnnotation\", \"VoidTypeAnnotation\", \"EmptyTypeAnnotation\", \"MixedTypeAnnotation\", \"BooleanTypeAnnotation\", \"BooleanLiteralTypeAnnotation\", \"StringTypeAnnotation\"];\n  return node && flowTypeAnnotations.indexOf(node.type) !== -1 && !(node.type === \"GenericTypeAnnotation\" && node.typeParameters);\n}\n\nfunction isJestEachTemplateLiteral(node, parentNode) {\n  /**\n   * describe.each`table`(name, fn)\n   * describe.only.each`table`(name, fn)\n   * describe.skip.each`table`(name, fn)\n   * test.each`table`(name, fn)\n   * test.only.each`table`(name, fn)\n   * test.skip.each`table`(name, fn)\n   *\n   * Ref: https://github.com/facebook/jest/pull/6102\n   */\n  var jestEachTriggerRegex = /^[xf]?(describe|it|test)$/;\n  return parentNode.type === \"TaggedTemplateExpression\" && parentNode.quasi === node && parentNode.tag.type === \"MemberExpression\" && parentNode.tag.property.type === \"Identifier\" && parentNode.tag.property.name === \"each\" && (parentNode.tag.object.type === \"Identifier\" && jestEachTriggerRegex.test(parentNode.tag.object.name) || parentNode.tag.object.type === \"MemberExpression\" && parentNode.tag.object.property.type === \"Identifier\" && (parentNode.tag.object.property.name === \"only\" || parentNode.tag.object.property.name === \"skip\") && parentNode.tag.object.object.type === \"Identifier\" && jestEachTriggerRegex.test(parentNode.tag.object.object.name));\n}\n\nfunction printJestEachTemplateLiteral(node, expressions, options) {\n  /**\n   * a    | b    | expected\n   * ${1} | ${1} | ${2}\n   * ${1} | ${2} | ${3}\n   * ${2} | ${1} | ${3}\n   */\n  var headerNames = node.quasis[0].value.raw.trim().split(/\\s*\\|\\s*/);\n\n  if (headerNames.length > 1 || headerNames.some(function (headerName) {\n    return headerName.length !== 0;\n  })) {\n    var parts = [];\n    var stringifiedExpressions = expressions.map(function (doc) {\n      return \"${\" + printDocToString(doc, Object.assign({}, options, {\n        printWidth: Infinity,\n        endOfLine: \"lf\"\n      })).formatted + \"}\";\n    });\n    var tableBody = [{\n      hasLineBreak: false,\n      cells: []\n    }];\n\n    for (var i = 1; i < node.quasis.length; i++) {\n      var row = tableBody[tableBody.length - 1];\n      var correspondingExpression = stringifiedExpressions[i - 1];\n      row.cells.push(correspondingExpression);\n\n      if (correspondingExpression.indexOf(\"\\n\") !== -1) {\n        row.hasLineBreak = true;\n      }\n\n      if (node.quasis[i].value.raw.indexOf(\"\\n\") !== -1) {\n        tableBody.push({\n          hasLineBreak: false,\n          cells: []\n        });\n      }\n    }\n\n    var maxColumnCount = tableBody.reduce(function (maxColumnCount, row) {\n      return Math.max(maxColumnCount, row.cells.length);\n    }, headerNames.length);\n    var maxColumnWidths = Array.from(new Array(maxColumnCount), function () {\n      return 0;\n    });\n    var table = [{\n      cells: headerNames\n    }].concat(tableBody.filter(function (row) {\n      return row.cells.length !== 0;\n    }));\n    table.filter(function (row) {\n      return !row.hasLineBreak;\n    }).forEach(function (row) {\n      row.cells.forEach(function (cell, index) {\n        maxColumnWidths[index] = Math.max(maxColumnWidths[index], getStringWidth(cell));\n      });\n    });\n    parts.push(lineSuffixBoundary, \"`\", indent(concat([hardline, join(hardline, table.map(function (row) {\n      return join(\" | \", row.cells.map(function (cell, index) {\n        return row.hasLineBreak ? cell : cell + \" \".repeat(maxColumnWidths[index] - getStringWidth(cell));\n      }));\n    }))])), hardline, \"`\");\n    return concat(parts);\n  }\n}\n/** @param node {import(\"estree\").TemplateLiteral} */\n\n\nfunction isSimpleTemplateLiteral(node) {\n  if (node.expressions.length === 0) {\n    return false;\n  }\n\n  return node.expressions.every(function (expr) {\n    // Disallow comments since printDocToString can't print them here\n    if (expr.comments) {\n      return false;\n    } // Allow `x` and `this`\n\n\n    if (expr.type === \"Identifier\" || expr.type === \"ThisExpression\") {\n      return true;\n    } // Allow `a.b.c`, `a.b[c]`, and `this.x.y`\n\n\n    if ((expr.type === \"MemberExpression\" || expr.type === \"OptionalMemberExpression\") && (expr.property.type === \"Identifier\" || expr.property.type === \"Literal\")) {\n      var ancestor = expr;\n\n      while (ancestor.type === \"MemberExpression\" || ancestor.type === \"OptionalMemberExpression\") {\n        ancestor = ancestor.object;\n\n        if (ancestor.comments) {\n          return false;\n        }\n      }\n\n      if (ancestor.type === \"Identifier\" || ancestor.type === \"ThisExpression\") {\n        return true;\n      }\n\n      return false;\n    }\n\n    return false;\n  });\n}\n\nvar functionCompositionFunctionNames = new Set([\"pipe\", // RxJS, Ramda\n\"pipeP\", // Ramda\n\"pipeK\", // Ramda\n\"compose\", // Ramda, Redux\n\"composeFlipped\", // Not from any library, but common in Haskell, so supported\n\"composeP\", // Ramda\n\"composeK\", // Ramda\n\"flow\", // Lodash\n\"flowRight\", // Lodash\n\"connect\", // Redux\n\"createSelector\" // Reselect\n]);\nvar ordinaryMethodNames = new Set([\"connect\" // GObject, MongoDB\n]);\n\nfunction isFunctionCompositionFunction(node) {\n  switch (node.type) {\n    case \"OptionalMemberExpression\":\n    case \"MemberExpression\":\n      {\n        return isFunctionCompositionFunction(node.property) && !ordinaryMethodNames.has(node.property.name);\n      }\n\n    case \"Identifier\":\n      {\n        return functionCompositionFunctionNames.has(node.name);\n      }\n\n    case \"StringLiteral\":\n    case \"Literal\":\n      {\n        return functionCompositionFunctionNames.has(node.value);\n      }\n  }\n}\n\nfunction printArgumentsList(path, options, print) {\n  var node = path.getValue();\n  var args = node.arguments;\n\n  if (args.length === 0) {\n    return concat([\"(\", comments.printDanglingComments(path, options,\n    /* sameIndent */\n    true), \")\"]);\n  } // useEffect(() => { ... }, [foo, bar, baz])\n\n\n  if (args.length === 2 && args[0].type === \"ArrowFunctionExpression\" && args[0].params.length === 0 && args[0].body.type === \"BlockStatement\" && args[1].type === \"ArrayExpression\" && !args.find(function (arg) {\n    return arg.comments;\n  })) {\n    return concat([\"(\", path.call(print, \"arguments\", 0), \", \", path.call(print, \"arguments\", 1), \")\"]);\n  } // func(\n  //   ({\n  //     a,\n  //     b\n  //   }) => {}\n  // );\n\n\n  function hasEmptyLineInObjectArgInArrowFunction(arg) {\n    return arg && arg.type === \"ArrowFunctionExpression\" && arg.params && arg.params.some(function (param) {\n      return param.type && param.type === \"ObjectPattern\" && param.properties && param.properties.some(function (property, i, properties) {\n        return i < properties.length - 1 && isNextLineEmpty(options.originalText, property, options);\n      });\n    });\n  }\n\n  var anyArgEmptyLine = false;\n  var hasEmptyLineFollowingFirstArg = false;\n  var lastArgIndex = args.length - 1;\n  var printedArguments = path.map(function (argPath, index) {\n    var arg = argPath.getNode();\n    var parts = [print(argPath)];\n\n    if (index === lastArgIndex) {// do nothing\n    } else if (isNextLineEmpty(options.originalText, arg, options)) {\n      if (index === 0) {\n        hasEmptyLineFollowingFirstArg = true;\n      }\n\n      anyArgEmptyLine = true;\n      parts.push(\",\", hardline, hardline);\n    } else {\n      parts.push(\",\", line);\n    }\n\n    anyArgEmptyLine = hasEmptyLineInObjectArgInArrowFunction(arg);\n    return concat(parts);\n  }, \"arguments\");\n  var maybeTrailingComma = // Dynamic imports cannot have trailing commas\n  !(node.callee && node.callee.type === \"Import\") && shouldPrintComma(options, \"all\") ? \",\" : \"\";\n\n  function allArgsBrokenOut() {\n    return group(concat([\"(\", indent(concat([line, concat(printedArguments)])), maybeTrailingComma, line, \")\"]), {\n      shouldBreak: true\n    });\n  } // We want to get\n  //    pipe(\n  //      x => x + 1,\n  //      x => x - 1\n  //    )\n  // here, but not\n  //    process.stdout.pipe(socket)\n\n\n  if (isFunctionCompositionFunction(node.callee) && args.length > 1) {\n    return allArgsBrokenOut();\n  }\n\n  var shouldGroupFirst = shouldGroupFirstArg(args);\n  var shouldGroupLast = shouldGroupLastArg(args);\n\n  if (shouldGroupFirst || shouldGroupLast) {\n    var shouldBreak = (shouldGroupFirst ? printedArguments.slice(1).some(willBreak) : printedArguments.slice(0, -1).some(willBreak)) || anyArgEmptyLine; // We want to print the last argument with a special flag\n\n    var printedExpanded;\n    var i = 0;\n    path.each(function (argPath) {\n      if (shouldGroupFirst && i === 0) {\n        printedExpanded = [concat([argPath.call(function (p) {\n          return print(p, {\n            expandFirstArg: true\n          });\n        }), printedArguments.length > 1 ? \",\" : \"\", hasEmptyLineFollowingFirstArg ? hardline : line, hasEmptyLineFollowingFirstArg ? hardline : \"\"])].concat(printedArguments.slice(1));\n      }\n\n      if (shouldGroupLast && i === args.length - 1) {\n        printedExpanded = printedArguments.slice(0, -1).concat(argPath.call(function (p) {\n          return print(p, {\n            expandLastArg: true\n          });\n        }));\n      }\n\n      i++;\n    }, \"arguments\");\n    var somePrintedArgumentsWillBreak = printedArguments.some(willBreak);\n    var simpleConcat = concat([\"(\", concat(printedExpanded), \")\"]);\n    return concat([somePrintedArgumentsWillBreak ? breakParent : \"\", conditionalGroup([!somePrintedArgumentsWillBreak ? simpleConcat : ifBreak(allArgsBrokenOut(), simpleConcat), shouldGroupFirst ? concat([\"(\", group(printedExpanded[0], {\n      shouldBreak: true\n    }), concat(printedExpanded.slice(1)), \")\"]) : concat([\"(\", concat(printedArguments.slice(0, -1)), group(getLast(printedExpanded), {\n      shouldBreak: true\n    }), \")\"]), allArgsBrokenOut()], {\n      shouldBreak: shouldBreak\n    })]);\n  }\n\n  return group(concat([\"(\", indent(concat([softline, concat(printedArguments)])), ifBreak(maybeTrailingComma), softline, \")\"]), {\n    shouldBreak: printedArguments.some(willBreak) || anyArgEmptyLine\n  });\n}\n\nfunction printTypeAnnotation(path, options, print) {\n  var node = path.getValue();\n\n  if (!node.typeAnnotation) {\n    return \"\";\n  }\n\n  var parentNode = path.getParentNode();\n  var isDefinite = node.definite || parentNode && parentNode.type === \"VariableDeclarator\" && parentNode.definite;\n  var isFunctionDeclarationIdentifier = parentNode.type === \"DeclareFunction\" && parentNode.id === node;\n\n  if (isFlowAnnotationComment(options.originalText, node.typeAnnotation, options)) {\n    return concat([\" /*: \", path.call(print, \"typeAnnotation\"), \" */\"]);\n  }\n\n  return concat([isFunctionDeclarationIdentifier ? \"\" : isDefinite ? \"!: \" : \": \", path.call(print, \"typeAnnotation\")]);\n}\n\nfunction printFunctionTypeParameters(path, options, print) {\n  var fun = path.getValue();\n\n  if (fun.typeArguments) {\n    return path.call(print, \"typeArguments\");\n  }\n\n  if (fun.typeParameters) {\n    return path.call(print, \"typeParameters\");\n  }\n\n  return \"\";\n}\n\nfunction printFunctionParams(path, print, options, expandArg, printTypeParams) {\n  var fun = path.getValue();\n  var parent = path.getParentNode();\n  var paramsField = fun.parameters ? \"parameters\" : \"params\";\n  var isParametersInTestCall = isTestCall(parent);\n  var shouldHugParameters = shouldHugArguments(fun);\n  var shouldExpandParameters = expandArg && !(fun[paramsField] && fun[paramsField].some(function (n) {\n    return n.comments;\n  }));\n  var typeParams = printTypeParams ? printFunctionTypeParameters(path, options, print) : \"\";\n  var printed = [];\n\n  if (fun[paramsField]) {\n    var lastArgIndex = fun[paramsField].length - 1;\n    printed = path.map(function (childPath, index) {\n      var parts = [];\n      var param = childPath.getValue();\n      parts.push(print(childPath));\n\n      if (index === lastArgIndex) {\n        if (fun.rest) {\n          parts.push(\",\", line);\n        }\n      } else if (isParametersInTestCall || shouldHugParameters || shouldExpandParameters) {\n        parts.push(\", \");\n      } else if (isNextLineEmpty(options.originalText, param, options)) {\n        parts.push(\",\", hardline, hardline);\n      } else {\n        parts.push(\",\", line);\n      }\n\n      return concat(parts);\n    }, paramsField);\n  }\n\n  if (fun.rest) {\n    printed.push(concat([\"...\", path.call(print, \"rest\")]));\n  }\n\n  if (printed.length === 0) {\n    return concat([typeParams, \"(\", comments.printDanglingComments(path, options,\n    /* sameIndent */\n    true, function (comment) {\n      return getNextNonSpaceNonCommentCharacter(options.originalText, comment, options.locEnd) === \")\";\n    }), \")\"]);\n  }\n\n  var lastParam = getLast(fun[paramsField]); // If the parent is a call with the first/last argument expansion and this is the\n  // params of the first/last argument, we dont want the arguments to break and instead\n  // want the whole expression to be on a new line.\n  //\n  // Good:                 Bad:\n  //   verylongcall(         verylongcall((\n  //     (a, b) => {           a,\n  //     }                     b,\n  //   })                    ) => {\n  //                         })\n\n  if (shouldExpandParameters) {\n    return group(concat([removeLines(typeParams), \"(\", concat(printed.map(removeLines)), \")\"]));\n  } // Single object destructuring should hug\n  //\n  // function({\n  //   a,\n  //   b,\n  //   c\n  // }) {}\n\n\n  var hasNotParameterDecorator = fun[paramsField].every(function (param) {\n    return !param.decorators;\n  });\n\n  if (shouldHugParameters && hasNotParameterDecorator) {\n    return concat([typeParams, \"(\", concat(printed), \")\"]);\n  } // don't break in specs, eg; `it(\"should maintain parens around done even when long\", (done) => {})`\n\n\n  if (isParametersInTestCall) {\n    return concat([typeParams, \"(\", concat(printed), \")\"]);\n  }\n\n  var isFlowShorthandWithOneArg = (isObjectTypePropertyAFunction(parent, options) || isTypeAnnotationAFunction(parent, options) || parent.type === \"TypeAlias\" || parent.type === \"UnionTypeAnnotation\" || parent.type === \"TSUnionType\" || parent.type === \"IntersectionTypeAnnotation\" || parent.type === \"FunctionTypeAnnotation\" && parent.returnType === fun) && fun[paramsField].length === 1 && fun[paramsField][0].name === null && fun[paramsField][0].typeAnnotation && fun.typeParameters === null && isSimpleFlowType(fun[paramsField][0].typeAnnotation) && !fun.rest;\n\n  if (isFlowShorthandWithOneArg) {\n    if (options.arrowParens === \"always\") {\n      return concat([\"(\", concat(printed), \")\"]);\n    }\n\n    return concat(printed);\n  }\n\n  var canHaveTrailingComma = !(lastParam && lastParam.type === \"RestElement\") && !fun.rest;\n  return concat([typeParams, \"(\", indent(concat([softline, concat(printed)])), ifBreak(canHaveTrailingComma && shouldPrintComma(options, \"all\") ? \",\" : \"\"), softline, \")\"]);\n}\n\nfunction shouldPrintParamsWithoutParens(path, options) {\n  if (options.arrowParens === \"always\") {\n    return false;\n  }\n\n  if (options.arrowParens === \"avoid\") {\n    var node = path.getValue();\n    return canPrintParamsWithoutParens(node);\n  } // Fallback default; should be unreachable\n\n\n  return false;\n}\n\nfunction canPrintParamsWithoutParens(node) {\n  return node.params.length === 1 && !node.rest && !node.typeParameters && !hasDanglingComments(node) && node.params[0].type === \"Identifier\" && !node.params[0].typeAnnotation && !node.params[0].comments && !node.params[0].optional && !node.predicate && !node.returnType;\n}\n\nfunction printFunctionDeclaration(path, print, options) {\n  var n = path.getValue();\n  var parts = [];\n\n  if (n.async) {\n    parts.push(\"async \");\n  }\n\n  parts.push(\"function\");\n\n  if (n.generator) {\n    parts.push(\"*\");\n  }\n\n  if (n.id) {\n    parts.push(\" \", path.call(print, \"id\"));\n  }\n\n  parts.push(printFunctionTypeParameters(path, options, print), group(concat([printFunctionParams(path, print, options), printReturnType(path, print, options)])), n.body ? \" \" : \"\", path.call(print, \"body\"));\n  return concat(parts);\n}\n\nfunction printObjectMethod(path, options, print) {\n  var objMethod = path.getValue();\n  var parts = [];\n\n  if (objMethod.async) {\n    parts.push(\"async \");\n  }\n\n  if (objMethod.generator) {\n    parts.push(\"*\");\n  }\n\n  if (objMethod.method || objMethod.kind === \"get\" || objMethod.kind === \"set\") {\n    return printMethod(path, options, print);\n  }\n\n  var key = printPropertyKey(path, options, print);\n\n  if (objMethod.computed) {\n    parts.push(\"[\", key, \"]\");\n  } else {\n    parts.push(key);\n  }\n\n  parts.push(printFunctionTypeParameters(path, options, print), group(concat([printFunctionParams(path, print, options), printReturnType(path, print, options)])), \" \", path.call(print, \"body\"));\n  return concat(parts);\n}\n\nfunction printReturnType(path, print, options) {\n  var n = path.getValue();\n  var returnType = path.call(print, \"returnType\");\n\n  if (n.returnType && isFlowAnnotationComment(options.originalText, n.returnType, options)) {\n    return concat([\" /*: \", returnType, \" */\"]);\n  }\n\n  var parts = [returnType]; // prepend colon to TypeScript type annotation\n\n  if (n.returnType && n.returnType.typeAnnotation) {\n    parts.unshift(\": \");\n  }\n\n  if (n.predicate) {\n    // The return type will already add the colon, but otherwise we\n    // need to do it ourselves\n    parts.push(n.returnType ? \" \" : \": \", path.call(print, \"predicate\"));\n  }\n\n  return concat(parts);\n}\n\nfunction printExportDeclaration(path, options, print) {\n  var decl = path.getValue();\n  var semi = options.semi ? \";\" : \"\";\n  var parts = [\"export \"];\n  var isDefault = decl[\"default\"] || decl.type === \"ExportDefaultDeclaration\";\n\n  if (isDefault) {\n    parts.push(\"default \");\n  }\n\n  parts.push(comments.printDanglingComments(path, options,\n  /* sameIndent */\n  true));\n\n  if (needsHardlineAfterDanglingComment(decl)) {\n    parts.push(hardline);\n  }\n\n  if (decl.declaration) {\n    parts.push(path.call(print, \"declaration\"));\n\n    if (isDefault && decl.declaration.type !== \"ClassDeclaration\" && decl.declaration.type !== \"FunctionDeclaration\" && decl.declaration.type !== \"TSInterfaceDeclaration\" && decl.declaration.type !== \"DeclareClass\" && decl.declaration.type !== \"DeclareFunction\" && decl.declaration.type !== \"TSDeclareFunction\") {\n      parts.push(semi);\n    }\n  } else {\n    if (decl.specifiers && decl.specifiers.length > 0) {\n      var specifiers = [];\n      var defaultSpecifiers = [];\n      var namespaceSpecifiers = [];\n      path.each(function (specifierPath) {\n        var specifierType = path.getValue().type;\n\n        if (specifierType === \"ExportSpecifier\") {\n          specifiers.push(print(specifierPath));\n        } else if (specifierType === \"ExportDefaultSpecifier\") {\n          defaultSpecifiers.push(print(specifierPath));\n        } else if (specifierType === \"ExportNamespaceSpecifier\") {\n          namespaceSpecifiers.push(concat([\"* as \", print(specifierPath)]));\n        }\n      }, \"specifiers\");\n      var isNamespaceFollowed = namespaceSpecifiers.length !== 0 && specifiers.length !== 0;\n      var isDefaultFollowed = defaultSpecifiers.length !== 0 && (namespaceSpecifiers.length !== 0 || specifiers.length !== 0);\n      var canBreak = specifiers.length > 1 || defaultSpecifiers.length > 0 || decl.specifiers && decl.specifiers.some(function (node) {\n        return node.comments;\n      });\n      var printed = \"\";\n\n      if (specifiers.length !== 0) {\n        if (canBreak) {\n          printed = group(concat([\"{\", indent(concat([options.bracketSpacing ? line : softline, join(concat([\",\", line]), specifiers)])), ifBreak(shouldPrintComma(options) ? \",\" : \"\"), options.bracketSpacing ? line : softline, \"}\"]));\n        } else {\n          printed = concat([\"{\", options.bracketSpacing ? \" \" : \"\", concat(specifiers), options.bracketSpacing ? \" \" : \"\", \"}\"]);\n        }\n      }\n\n      parts.push(decl.exportKind === \"type\" ? \"type \" : \"\", concat(defaultSpecifiers), concat([isDefaultFollowed ? \", \" : \"\"]), concat(namespaceSpecifiers), concat([isNamespaceFollowed ? \", \" : \"\"]), printed);\n    } else {\n      parts.push(\"{}\");\n    }\n\n    if (decl.source) {\n      parts.push(\" from \", path.call(print, \"source\"));\n    }\n\n    parts.push(semi);\n  }\n\n  return concat(parts);\n}\n\nfunction printFlowDeclaration(path, parts) {\n  var parentExportDecl = getParentExportDeclaration(path);\n\n  if (parentExportDecl) {\n    assert.strictEqual(parentExportDecl.type, \"DeclareExportDeclaration\");\n  } else {\n    // If the parent node has type DeclareExportDeclaration, then it\n    // will be responsible for printing the \"declare\" token. Otherwise\n    // it needs to be printed with this non-exported declaration node.\n    parts.unshift(\"declare \");\n  }\n\n  return concat(parts);\n}\n\nfunction getFlowVariance(path) {\n  if (!path.variance) {\n    return null;\n  } // Babel 7.0 currently uses variance node type, and flow should\n  // follow suit soon:\n  // https://github.com/babel/babel/issues/4722\n\n\n  var variance = path.variance.kind || path.variance;\n\n  switch (variance) {\n    case \"plus\":\n      return \"+\";\n\n    case \"minus\":\n      return \"-\";\n\n    default:\n      /* istanbul ignore next */\n      return variance;\n  }\n}\n\nfunction printTypeScriptModifiers(path, options, print) {\n  var n = path.getValue();\n\n  if (!n.modifiers || !n.modifiers.length) {\n    return \"\";\n  }\n\n  return concat([join(\" \", path.map(print, \"modifiers\")), \" \"]);\n}\n\nfunction printTypeParameters(path, options, print, paramsKey) {\n  var n = path.getValue();\n\n  if (!n[paramsKey]) {\n    return \"\";\n  } // for TypeParameterDeclaration typeParameters is a single node\n\n\n  if (!Array.isArray(n[paramsKey])) {\n    return path.call(print, paramsKey);\n  }\n\n  var grandparent = path.getNode(2);\n  var isParameterInTestCall = grandparent != null && isTestCall(grandparent);\n  var shouldInline = isParameterInTestCall || n[paramsKey].length === 0 || n[paramsKey].length === 1 && (shouldHugType(n[paramsKey][0]) || n[paramsKey][0].type === \"GenericTypeAnnotation\" && shouldHugType(n[paramsKey][0].id) || n[paramsKey][0].type === \"TSTypeReference\" && shouldHugType(n[paramsKey][0].typeName) || n[paramsKey][0].type === \"NullableTypeAnnotation\");\n\n  if (shouldInline) {\n    return concat([\"<\", join(\", \", path.map(print, paramsKey)), \">\"]);\n  }\n\n  return group(concat([\"<\", indent(concat([softline, join(concat([\",\", line]), path.map(print, paramsKey))])), ifBreak(options.parser !== \"typescript\" && shouldPrintComma(options, \"all\") ? \",\" : \"\"), softline, \">\"]));\n}\n\nfunction printClass(path, options, print) {\n  var n = path.getValue();\n  var parts = [];\n\n  if (n[\"abstract\"]) {\n    parts.push(\"abstract \");\n  }\n\n  parts.push(\"class\");\n\n  if (n.id) {\n    parts.push(\" \", path.call(print, \"id\"));\n  }\n\n  parts.push(path.call(print, \"typeParameters\"));\n  var partsGroup = [];\n\n  if (n.superClass) {\n    var printed = concat([\"extends \", path.call(print, \"superClass\"), path.call(print, \"superTypeParameters\")]); // Keep old behaviour of extends in same line\n    // If there is only on extends and there are not comments\n\n    if ((!n[\"implements\"] || n[\"implements\"].length === 0) && (!n.superClass.comments || n.superClass.comments.length === 0)) {\n      parts.push(concat([\" \", path.call(function (superClass) {\n        return comments.printComments(superClass, function () {\n          return printed;\n        }, options);\n      }, \"superClass\")]));\n    } else {\n      partsGroup.push(group(concat([line, path.call(function (superClass) {\n        return comments.printComments(superClass, function () {\n          return printed;\n        }, options);\n      }, \"superClass\")])));\n    }\n  } else if (n[\"extends\"] && n[\"extends\"].length > 0) {\n    parts.push(\" extends \", join(\", \", path.map(print, \"extends\")));\n  }\n\n  if (n[\"mixins\"] && n[\"mixins\"].length > 0) {\n    partsGroup.push(line, \"mixins \", group(indent(join(concat([\",\", line]), path.map(print, \"mixins\")))));\n  }\n\n  if (n[\"implements\"] && n[\"implements\"].length > 0) {\n    partsGroup.push(line, \"implements\", group(indent(concat([line, join(concat([\",\", line]), path.map(print, \"implements\"))]))));\n  }\n\n  if (partsGroup.length > 0) {\n    parts.push(group(indent(concat(partsGroup))));\n  }\n\n  if (n.body && n.body.comments && hasLeadingOwnLineComment(options.originalText, n.body, options)) {\n    parts.push(hardline);\n  } else {\n    parts.push(\" \");\n  }\n\n  parts.push(path.call(print, \"body\"));\n  return parts;\n}\n\nfunction printOptionalToken(path) {\n  var node = path.getValue();\n\n  if (!node.optional) {\n    return \"\";\n  }\n\n  if (node.type === \"OptionalCallExpression\" || node.type === \"OptionalMemberExpression\" && node.computed) {\n    return \"?.\";\n  }\n\n  return \"?\";\n}\n\nfunction printMemberLookup(path, options, print) {\n  var property = path.call(print, \"property\");\n  var n = path.getValue();\n  var optional = printOptionalToken(path);\n\n  if (!n.computed) {\n    return concat([optional, \".\", property]);\n  }\n\n  if (!n.property || isNumericLiteral(n.property)) {\n    return concat([optional, \"[\", property, \"]\"]);\n  }\n\n  return group(concat([optional, \"[\", indent(concat([softline, property])), softline, \"]\"]));\n}\n\nfunction printBindExpressionCallee(path, options, print) {\n  return concat([\"::\", path.call(print, \"callee\")]);\n} // We detect calls on member expressions specially to format a\n// common pattern better. The pattern we are looking for is this:\n//\n// arr\n//   .map(x => x + 1)\n//   .filter(x => x > 10)\n//   .some(x => x % 2)\n//\n// The way it is structured in the AST is via a nested sequence of\n// MemberExpression and CallExpression. We need to traverse the AST\n// and make groups out of it to print it in the desired way.\n\n\nfunction printMemberChain(path, options, print) {\n  // The first phase is to linearize the AST by traversing it down.\n  //\n  //   a().b()\n  // has the following AST structure:\n  //   CallExpression(MemberExpression(CallExpression(Identifier)))\n  // and we transform it into\n  //   [Identifier, CallExpression, MemberExpression, CallExpression]\n  var printedNodes = []; // Here we try to retain one typed empty line after each call expression or\n  // the first group whether it is in parentheses or not\n\n  function shouldInsertEmptyLineAfter(node) {\n    var originalText = options.originalText;\n    var nextCharIndex = getNextNonSpaceNonCommentCharacterIndex(originalText, node, options);\n    var nextChar = originalText.charAt(nextCharIndex); // if it is cut off by a parenthesis, we only account for one typed empty\n    // line after that parenthesis\n\n    if (nextChar == \")\") {\n      return isNextLineEmptyAfterIndex(originalText, nextCharIndex + 1, options);\n    }\n\n    return isNextLineEmpty(originalText, node, options);\n  }\n\n  function rec(path) {\n    var node = path.getValue();\n\n    if ((node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\") && (isMemberish(node.callee) || node.callee.type === \"CallExpression\" || node.callee.type === \"OptionalCallExpression\")) {\n      printedNodes.unshift({\n        node: node,\n        printed: concat([comments.printComments(path, function () {\n          return concat([printOptionalToken(path), printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)]);\n        }, options), shouldInsertEmptyLineAfter(node) ? hardline : \"\"])\n      });\n      path.call(function (callee) {\n        return rec(callee);\n      }, \"callee\");\n    } else if (isMemberish(node)) {\n      printedNodes.unshift({\n        node: node,\n        needsParens: pathNeedsParens(path, options),\n        printed: comments.printComments(path, function () {\n          return node.type === \"OptionalMemberExpression\" || node.type === \"MemberExpression\" ? printMemberLookup(path, options, print) : printBindExpressionCallee(path, options, print);\n        }, options)\n      });\n      path.call(function (object) {\n        return rec(object);\n      }, \"object\");\n    } else if (node.type === \"TSNonNullExpression\") {\n      printedNodes.unshift({\n        node: node,\n        printed: comments.printComments(path, function () {\n          return \"!\";\n        }, options)\n      });\n      path.call(function (expression) {\n        return rec(expression);\n      }, \"expression\");\n    } else {\n      printedNodes.unshift({\n        node: node,\n        printed: path.call(print)\n      });\n    }\n  } // Note: the comments of the root node have already been printed, so we\n  // need to extract this first call without printing them as they would\n  // if handled inside of the recursive call.\n\n\n  var node = path.getValue();\n  printedNodes.unshift({\n    node: node,\n    printed: concat([printOptionalToken(path), printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)])\n  });\n  path.call(function (callee) {\n    return rec(callee);\n  }, \"callee\"); // Once we have a linear list of printed nodes, we want to create groups out\n  // of it.\n  //\n  //   a().b.c().d().e\n  // will be grouped as\n  //   [\n  //     [Identifier, CallExpression],\n  //     [MemberExpression, MemberExpression, CallExpression],\n  //     [MemberExpression, CallExpression],\n  //     [MemberExpression],\n  //   ]\n  // so that we can print it as\n  //   a()\n  //     .b.c()\n  //     .d()\n  //     .e\n  // The first group is the first node followed by\n  //   - as many CallExpression as possible\n  //       < fn()()() >.something()\n  //   - as many array acessors as possible\n  //       < fn()[0][1][2] >.something()\n  //   - then, as many MemberExpression as possible but the last one\n  //       < this.items >.something()\n\n  var groups = [];\n  var currentGroup = [printedNodes[0]];\n  var i = 1;\n\n  for (; i < printedNodes.length; ++i) {\n    if (printedNodes[i].node.type === \"TSNonNullExpression\" || printedNodes[i].node.type === \"OptionalCallExpression\" || printedNodes[i].node.type === \"CallExpression\" || (printedNodes[i].node.type === \"MemberExpression\" || printedNodes[i].node.type === \"OptionalMemberExpression\") && printedNodes[i].node.computed && isNumericLiteral(printedNodes[i].node.property)) {\n      currentGroup.push(printedNodes[i]);\n    } else {\n      break;\n    }\n  }\n\n  if (printedNodes[0].node.type !== \"CallExpression\" && printedNodes[0].node.type !== \"OptionalCallExpression\") {\n    for (; i + 1 < printedNodes.length; ++i) {\n      if (isMemberish(printedNodes[i].node) && isMemberish(printedNodes[i + 1].node)) {\n        currentGroup.push(printedNodes[i]);\n      } else {\n        break;\n      }\n    }\n  }\n\n  groups.push(currentGroup);\n  currentGroup = []; // Then, each following group is a sequence of MemberExpression followed by\n  // a sequence of CallExpression. To compute it, we keep adding things to the\n  // group until we has seen a CallExpression in the past and reach a\n  // MemberExpression\n\n  var hasSeenCallExpression = false;\n\n  for (; i < printedNodes.length; ++i) {\n    if (hasSeenCallExpression && isMemberish(printedNodes[i].node)) {\n      // [0] should be appended at the end of the group instead of the\n      // beginning of the next one\n      if (printedNodes[i].node.computed && isNumericLiteral(printedNodes[i].node.property)) {\n        currentGroup.push(printedNodes[i]);\n        continue;\n      }\n\n      groups.push(currentGroup);\n      currentGroup = [];\n      hasSeenCallExpression = false;\n    }\n\n    if (printedNodes[i].node.type === \"CallExpression\" || printedNodes[i].node.type === \"OptionalCallExpression\") {\n      hasSeenCallExpression = true;\n    }\n\n    currentGroup.push(printedNodes[i]);\n\n    if (printedNodes[i].node.comments && printedNodes[i].node.comments.some(function (comment) {\n      return comment.trailing;\n    })) {\n      groups.push(currentGroup);\n      currentGroup = [];\n      hasSeenCallExpression = false;\n    }\n  }\n\n  if (currentGroup.length > 0) {\n    groups.push(currentGroup);\n  } // There are cases like Object.keys(), Observable.of(), _.values() where\n  // they are the subject of all the chained calls and therefore should\n  // be kept on the same line:\n  //\n  //   Object.keys(items)\n  //     .filter(x => x)\n  //     .map(x => x)\n  //\n  // In order to detect those cases, we use an heuristic: if the first\n  // node is an identifier with the name starting with a capital\n  // letter or just a sequence of _$. The rationale is that they are\n  // likely to be factories.\n\n\n  function isFactory(name) {\n    return /^[A-Z]|^[_$]+$/.test(name);\n  } // In case the Identifier is shorter than tab width, we can keep the\n  // first call in a single line, if it's an ExpressionStatement.\n  //\n  //   d3.scaleLinear()\n  //     .domain([0, 100])\n  //     .range([0, width]);\n  //\n\n\n  function isShort(name) {\n    return name.length <= options.tabWidth;\n  }\n\n  function shouldNotWrap(groups) {\n    var parent = path.getParentNode();\n    var isExpression = parent && parent.type === \"ExpressionStatement\";\n    var hasComputed = groups[1].length && groups[1][0].node.computed;\n\n    if (groups[0].length === 1) {\n      var firstNode = groups[0][0].node;\n      return firstNode.type === \"ThisExpression\" || firstNode.type === \"Identifier\" && (isFactory(firstNode.name) || isExpression && isShort(firstNode.name) || hasComputed);\n    }\n\n    var lastNode = getLast(groups[0]).node;\n    return (lastNode.type === \"MemberExpression\" || lastNode.type === \"OptionalMemberExpression\") && lastNode.property.type === \"Identifier\" && (isFactory(lastNode.property.name) || hasComputed);\n  }\n\n  var shouldMerge = groups.length >= 2 && !groups[1][0].node.comments && shouldNotWrap(groups);\n\n  function printGroup(printedGroup) {\n    var printed = printedGroup.map(function (tuple) {\n      return tuple.printed;\n    }); // Checks if the last node (i.e. the parent node) needs parens and print\n    // accordingly\n\n    if (printedGroup.length > 0 && printedGroup[printedGroup.length - 1].needsParens) {\n      return concat([\"(\"].concat(_toConsumableArray(printed), [\")\"]));\n    }\n\n    return concat(printed);\n  }\n\n  function printIndentedGroup(groups) {\n    if (groups.length === 0) {\n      return \"\";\n    }\n\n    return indent(group(concat([hardline, join(hardline, groups.map(printGroup))])));\n  }\n\n  var printedGroups = groups.map(printGroup);\n  var oneLine = concat(printedGroups);\n  var cutoff = shouldMerge ? 3 : 2;\n  var flatGroups = groups.slice(0, cutoff).reduce(function (res, group) {\n    return res.concat(group);\n  }, []);\n  var hasComment = flatGroups.slice(1, -1).some(function (node) {\n    return hasLeadingComment(node.node);\n  }) || flatGroups.slice(0, -1).some(function (node) {\n    return hasTrailingComment(node.node);\n  }) || groups[cutoff] && hasLeadingComment(groups[cutoff][0].node); // If we only have a single `.`, we shouldn't do anything fancy and just\n  // render everything concatenated together.\n\n  if (groups.length <= cutoff && !hasComment) {\n    return group(oneLine);\n  } // Find out the last node in the first group and check if it has an\n  // empty line after\n\n\n  var lastNodeBeforeIndent = getLast(shouldMerge ? groups.slice(1, 2)[0] : groups[0]).node;\n  var shouldHaveEmptyLineBeforeIndent = lastNodeBeforeIndent.type !== \"CallExpression\" && lastNodeBeforeIndent.type !== \"OptionalCallExpression\" && shouldInsertEmptyLineAfter(lastNodeBeforeIndent);\n  var expanded = concat([printGroup(groups[0]), shouldMerge ? concat(groups.slice(1, 2).map(printGroup)) : \"\", shouldHaveEmptyLineBeforeIndent ? hardline : \"\", printIndentedGroup(groups.slice(shouldMerge ? 2 : 1))]);\n  var callExpressions = printedNodes.map(function (_ref) {\n    var node = _ref.node;\n    return node;\n  }).filter(isCallOrOptionalCallExpression); // We don't want to print in one line if there's:\n  //  * A comment.\n  //  * 3 or more chained calls.\n  //  * Any group but the last one has a hard line.\n  // If the last group is a function it's okay to inline if it fits.\n\n  if (hasComment || callExpressions.length >= 3 || printedGroups.slice(0, -1).some(willBreak) ||\n  /**\n   *     scopes.filter(scope => scope.value !== '').map((scope, i) => {\n   *       // multi line content\n   *     })\n   */\n  function (lastGroupDoc, lastGroupNode) {\n    return isCallOrOptionalCallExpression(lastGroupNode) && willBreak(lastGroupDoc);\n  }(getLast(printedGroups), getLast(getLast(groups)).node) && callExpressions.slice(0, -1).some(function (n) {\n    return n.arguments.some(isFunctionOrArrowExpression);\n  })) {\n    return group(expanded);\n  }\n\n  return concat([// We only need to check `oneLine` because if `expanded` is chosen\n  // that means that the parent group has already been broken\n  // naturally\n  willBreak(oneLine) || shouldHaveEmptyLineBeforeIndent ? breakParent : \"\", conditionalGroup([oneLine, expanded])]);\n}\n\nfunction isCallOrOptionalCallExpression(node) {\n  return node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\";\n}\n\nfunction isJSXNode(node) {\n  return node.type === \"JSXElement\" || node.type === \"JSXFragment\";\n}\n\nfunction isEmptyJSXElement(node) {\n  if (node.children.length === 0) {\n    return true;\n  }\n\n  if (node.children.length > 1) {\n    return false;\n  } // if there is one text child and does not contain any meaningful text\n  // we can treat the element as empty.\n\n\n  var child = node.children[0];\n  return isLiteral(child) && !isMeaningfulJSXText(child);\n} // Only space, newline, carriage return, and tab are treated as whitespace\n// inside JSX.\n\n\nvar jsxWhitespaceChars = \" \\n\\r\\t\";\nvar containsNonJsxWhitespaceRegex = new RegExp(\"[^\" + jsxWhitespaceChars + \"]\");\nvar matchJsxWhitespaceRegex = new RegExp(\"([\" + jsxWhitespaceChars + \"]+)\"); // Meaningful if it contains non-whitespace characters,\n// or it contains whitespace without a new line.\n\nfunction isMeaningfulJSXText(node) {\n  return isLiteral(node) && (containsNonJsxWhitespaceRegex.test(rawText(node)) || !/\\n/.test(rawText(node)));\n}\n\nfunction conditionalExpressionChainContainsJSX(node) {\n  return Boolean(getConditionalChainContents(node).find(isJSXNode));\n} // If we have nested conditional expressions, we want to print them in JSX mode\n// if there's at least one JSXElement somewhere in the tree.\n//\n// A conditional expression chain like this should be printed in normal mode,\n// because there aren't JSXElements anywhere in it:\n//\n// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : \"Unknown\";\n//\n// But a conditional expression chain like this should be printed in JSX mode,\n// because there is a JSXElement in the last ConditionalExpression:\n//\n// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : <span className=\"warning\">Unknown</span>;\n//\n// This type of ConditionalExpression chain is structured like this in the AST:\n//\n// ConditionalExpression {\n//   test: ...,\n//   consequent: ...,\n//   alternate: ConditionalExpression {\n//     test: ...,\n//     consequent: ...,\n//     alternate: ConditionalExpression {\n//       test: ...,\n//       consequent: ...,\n//       alternate: ...,\n//     }\n//   }\n// }\n//\n// We want to traverse over that shape and convert it into a flat structure so\n// that we can find if there's a JSXElement somewhere inside.\n\n\nfunction getConditionalChainContents(node) {\n  // Given this code:\n  //\n  // // Using a ConditionalExpression as the consequent is uncommon, but should\n  // // be handled.\n  // A ? B : C ? D : E ? F ? G : H : I\n  //\n  // which has this AST:\n  //\n  // ConditionalExpression {\n  //   test: Identifier(A),\n  //   consequent: Identifier(B),\n  //   alternate: ConditionalExpression {\n  //     test: Identifier(C),\n  //     consequent: Identifier(D),\n  //     alternate: ConditionalExpression {\n  //       test: Identifier(E),\n  //       consequent: ConditionalExpression {\n  //         test: Identifier(F),\n  //         consequent: Identifier(G),\n  //         alternate: Identifier(H),\n  //       },\n  //       alternate: Identifier(I),\n  //     }\n  //   }\n  // }\n  //\n  // we should return this Array:\n  //\n  // [\n  //   Identifier(A),\n  //   Identifier(B),\n  //   Identifier(C),\n  //   Identifier(D),\n  //   Identifier(E),\n  //   Identifier(F),\n  //   Identifier(G),\n  //   Identifier(H),\n  //   Identifier(I)\n  // ];\n  //\n  // This loses the information about whether each node was the test,\n  // consequent, or alternate, but we don't care about that here- we are only\n  // flattening this structure to find if there's any JSXElements inside.\n  var nonConditionalExpressions = [];\n\n  function recurse(node) {\n    if (node.type === \"ConditionalExpression\") {\n      recurse(node.test);\n      recurse(node.consequent);\n      recurse(node.alternate);\n    } else {\n      nonConditionalExpressions.push(node);\n    }\n  }\n\n  recurse(node);\n  return nonConditionalExpressions;\n} // Detect an expression node representing `{\" \"}`\n\n\nfunction isJSXWhitespaceExpression(node) {\n  return node.type === \"JSXExpressionContainer\" && isLiteral(node.expression) && node.expression.value === \" \" && !node.expression.comments;\n}\n\nfunction separatorNoWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {\n  if (isFacebookTranslationTag) {\n    return \"\";\n  }\n\n  if (childNode.type === \"JSXElement\" && !childNode.closingElement || nextNode && nextNode.type === \"JSXElement\" && !nextNode.closingElement) {\n    return child.length === 1 ? softline : hardline;\n  }\n\n  return softline;\n}\n\nfunction separatorWithWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {\n  if (isFacebookTranslationTag) {\n    return hardline;\n  }\n\n  if (child.length === 1) {\n    return childNode.type === \"JSXElement\" && !childNode.closingElement || nextNode && nextNode.type === \"JSXElement\" && !nextNode.closingElement ? hardline : softline;\n  }\n\n  return hardline;\n} // JSX Children are strange, mostly for two reasons:\n// 1. JSX reads newlines into string values, instead of skipping them like JS\n// 2. up to one whitespace between elements within a line is significant,\n//    but not between lines.\n//\n// Leading, trailing, and lone whitespace all need to\n// turn themselves into the rather ugly `{' '}` when breaking.\n//\n// We print JSX using the `fill` doc primitive.\n// This requires that we give it an array of alternating\n// content and whitespace elements.\n// To ensure this we add dummy `\"\"` content elements as needed.\n\n\nfunction printJSXChildren(path, options, print, jsxWhitespace, isFacebookTranslationTag) {\n  var n = path.getValue();\n  var children = []; // using `map` instead of `each` because it provides `i`\n\n  path.map(function (childPath, i) {\n    var child = childPath.getValue();\n\n    if (isLiteral(child)) {\n      var text = rawText(child); // Contains a non-whitespace character\n\n      if (isMeaningfulJSXText(child)) {\n        var words = text.split(matchJsxWhitespaceRegex); // Starts with whitespace\n\n        if (words[0] === \"\") {\n          children.push(\"\");\n          words.shift();\n\n          if (/\\n/.test(words[0])) {\n            var next = n.children[i + 1];\n            children.push(separatorWithWhitespace(isFacebookTranslationTag, words[1], child, next));\n          } else {\n            children.push(jsxWhitespace);\n          }\n\n          words.shift();\n        }\n\n        var endWhitespace; // Ends with whitespace\n\n        if (getLast(words) === \"\") {\n          words.pop();\n          endWhitespace = words.pop();\n        } // This was whitespace only without a new line.\n\n\n        if (words.length === 0) {\n          return;\n        }\n\n        words.forEach(function (word, i) {\n          if (i % 2 === 1) {\n            children.push(line);\n          } else {\n            children.push(word);\n          }\n        });\n\n        if (endWhitespace !== undefined) {\n          if (/\\n/.test(endWhitespace)) {\n            var _next = n.children[i + 1];\n            children.push(separatorWithWhitespace(isFacebookTranslationTag, getLast(children), child, _next));\n          } else {\n            children.push(jsxWhitespace);\n          }\n        } else {\n          var _next2 = n.children[i + 1];\n          children.push(separatorNoWhitespace(isFacebookTranslationTag, getLast(children), child, _next2));\n        }\n      } else if (/\\n/.test(text)) {\n        // Keep (up to one) blank line between tags/expressions/text.\n        // Note: We don't keep blank lines between text elements.\n        if (text.match(/\\n/g).length > 1) {\n          children.push(\"\");\n          children.push(hardline);\n        }\n      } else {\n        children.push(\"\");\n        children.push(jsxWhitespace);\n      }\n    } else {\n      var printedChild = print(childPath);\n      children.push(printedChild);\n      var _next3 = n.children[i + 1];\n\n      var directlyFollowedByMeaningfulText = _next3 && isMeaningfulJSXText(_next3);\n\n      if (directlyFollowedByMeaningfulText) {\n        var firstWord = rawText(_next3).trim().split(matchJsxWhitespaceRegex)[0];\n        children.push(separatorNoWhitespace(isFacebookTranslationTag, firstWord, child, _next3));\n      } else {\n        children.push(hardline);\n      }\n    }\n  }, \"children\");\n  return children;\n} // JSX expands children from the inside-out, instead of the outside-in.\n// This is both to break children before attributes,\n// and to ensure that when children break, their parents do as well.\n//\n// Any element that is written without any newlines and fits on a single line\n// is left that way.\n// Not only that, any user-written-line containing multiple JSX siblings\n// should also be kept on one line if possible,\n// so each user-written-line is wrapped in its own group.\n//\n// Elements that contain newlines or don't fit on a single line (recursively)\n// are fully-split, using hardline and shouldBreak: true.\n//\n// To support that case properly, all leading and trailing spaces\n// are stripped from the list of children, and replaced with a single hardline.\n\n\nfunction printJSXElement(path, options, print) {\n  var n = path.getValue();\n\n  if (n.type === \"JSXElement\" && isEmptyJSXElement(n)) {\n    return concat([path.call(print, \"openingElement\"), path.call(print, \"closingElement\")]);\n  }\n\n  var openingLines = n.type === \"JSXElement\" ? path.call(print, \"openingElement\") : path.call(print, \"openingFragment\");\n  var closingLines = n.type === \"JSXElement\" ? path.call(print, \"closingElement\") : path.call(print, \"closingFragment\");\n\n  if (n.children.length === 1 && n.children[0].type === \"JSXExpressionContainer\" && (n.children[0].expression.type === \"TemplateLiteral\" || n.children[0].expression.type === \"TaggedTemplateExpression\")) {\n    return concat([openingLines, concat(path.map(print, \"children\")), closingLines]);\n  } // Convert `{\" \"}` to text nodes containing a space.\n  // This makes it easy to turn them into `jsxWhitespace` which\n  // can then print as either a space or `{\" \"}` when breaking.\n\n\n  n.children = n.children.map(function (child) {\n    if (isJSXWhitespaceExpression(child)) {\n      return {\n        type: \"JSXText\",\n        value: \" \",\n        raw: \" \"\n      };\n    }\n\n    return child;\n  });\n  var containsTag = n.children.filter(isJSXNode).length > 0;\n  var containsMultipleExpressions = n.children.filter(function (child) {\n    return child.type === \"JSXExpressionContainer\";\n  }).length > 1;\n  var containsMultipleAttributes = n.type === \"JSXElement\" && n.openingElement.attributes.length > 1; // Record any breaks. Should never go from true to false, only false to true.\n\n  var forcedBreak = willBreak(openingLines) || containsTag || containsMultipleAttributes || containsMultipleExpressions;\n  var rawJsxWhitespace = options.singleQuote ? \"{' '}\" : '{\" \"}';\n  var jsxWhitespace = ifBreak(concat([rawJsxWhitespace, softline]), \" \");\n  var isFacebookTranslationTag = n.openingElement && n.openingElement.name && n.openingElement.name.name === \"fbt\";\n  var children = printJSXChildren(path, options, print, jsxWhitespace, isFacebookTranslationTag);\n  var containsText = n.children.filter(function (child) {\n    return isMeaningfulJSXText(child);\n  }).length > 0; // We can end up we multiple whitespace elements with empty string\n  // content between them.\n  // We need to remove empty whitespace and softlines before JSX whitespace\n  // to get the correct output.\n\n  for (var i = children.length - 2; i >= 0; i--) {\n    var isPairOfEmptyStrings = children[i] === \"\" && children[i + 1] === \"\";\n    var isPairOfHardlines = children[i] === hardline && children[i + 1] === \"\" && children[i + 2] === hardline;\n    var isLineFollowedByJSXWhitespace = (children[i] === softline || children[i] === hardline) && children[i + 1] === \"\" && children[i + 2] === jsxWhitespace;\n    var isJSXWhitespaceFollowedByLine = children[i] === jsxWhitespace && children[i + 1] === \"\" && (children[i + 2] === softline || children[i + 2] === hardline);\n    var isDoubleJSXWhitespace = children[i] === jsxWhitespace && children[i + 1] === \"\" && children[i + 2] === jsxWhitespace;\n    var isPairOfHardOrSoftLines = children[i] === softline && children[i + 1] === \"\" && children[i + 2] === hardline || children[i] === hardline && children[i + 1] === \"\" && children[i + 2] === softline;\n\n    if (isPairOfHardlines && containsText || isPairOfEmptyStrings || isLineFollowedByJSXWhitespace || isDoubleJSXWhitespace || isPairOfHardOrSoftLines) {\n      children.splice(i, 2);\n    } else if (isJSXWhitespaceFollowedByLine) {\n      children.splice(i + 1, 2);\n    }\n  } // Trim trailing lines (or empty strings)\n\n\n  while (children.length && (isLineNext(getLast(children)) || isEmpty(getLast(children)))) {\n    children.pop();\n  } // Trim leading lines (or empty strings)\n\n\n  while (children.length && (isLineNext(children[0]) || isEmpty(children[0])) && (isLineNext(children[1]) || isEmpty(children[1]))) {\n    children.shift();\n    children.shift();\n  } // Tweak how we format children if outputting this element over multiple lines.\n  // Also detect whether we will force this element to output over multiple lines.\n\n\n  var multilineChildren = [];\n  children.forEach(function (child, i) {\n    // There are a number of situations where we need to ensure we display\n    // whitespace as `{\" \"}` when outputting this element over multiple lines.\n    if (child === jsxWhitespace) {\n      if (i === 1 && children[i - 1] === \"\") {\n        if (children.length === 2) {\n          // Solitary whitespace\n          multilineChildren.push(rawJsxWhitespace);\n          return;\n        } // Leading whitespace\n\n\n        multilineChildren.push(concat([rawJsxWhitespace, hardline]));\n        return;\n      } else if (i === children.length - 1) {\n        // Trailing whitespace\n        multilineChildren.push(rawJsxWhitespace);\n        return;\n      } else if (children[i - 1] === \"\" && children[i - 2] === hardline) {\n        // Whitespace after line break\n        multilineChildren.push(rawJsxWhitespace);\n        return;\n      }\n    }\n\n    multilineChildren.push(child);\n\n    if (willBreak(child)) {\n      forcedBreak = true;\n    }\n  }); // If there is text we use `fill` to fit as much onto each line as possible.\n  // When there is no text (just tags and expressions) we use `group`\n  // to output each on a separate line.\n\n  var content = containsText ? fill(multilineChildren) : group(concat(multilineChildren), {\n    shouldBreak: true\n  });\n  var multiLineElem = group(concat([openingLines, indent(concat([hardline, content])), hardline, closingLines]));\n\n  if (forcedBreak) {\n    return multiLineElem;\n  }\n\n  return conditionalGroup([group(concat([openingLines, concat(children), closingLines])), multiLineElem]);\n}\n\nfunction maybeWrapJSXElementInParens(path, elem) {\n  var parent = path.getParentNode();\n\n  if (!parent) {\n    return elem;\n  }\n\n  var NO_WRAP_PARENTS = {\n    ArrayExpression: true,\n    JSXAttribute: true,\n    JSXElement: true,\n    JSXExpressionContainer: true,\n    JSXFragment: true,\n    ExpressionStatement: true,\n    CallExpression: true,\n    OptionalCallExpression: true,\n    ConditionalExpression: true,\n    JsExpressionRoot: true\n  };\n\n  if (NO_WRAP_PARENTS[parent.type]) {\n    return elem;\n  }\n\n  var shouldBreak = matchAncestorTypes(path, [\"ArrowFunctionExpression\", \"CallExpression\", \"JSXExpressionContainer\"]);\n  return group(concat([ifBreak(\"(\"), indent(concat([softline, elem])), softline, ifBreak(\")\")]), {\n    shouldBreak: shouldBreak\n  });\n}\n\nfunction isBinaryish(node) {\n  return node.type === \"BinaryExpression\" || node.type === \"LogicalExpression\" || node.type === \"NGPipeExpression\";\n}\n\nfunction isMemberish(node) {\n  return node.type === \"MemberExpression\" || node.type === \"OptionalMemberExpression\" || node.type === \"BindExpression\" && node.object;\n}\n\nfunction shouldInlineLogicalExpression(node) {\n  if (node.type !== \"LogicalExpression\") {\n    return false;\n  }\n\n  if (node.right.type === \"ObjectExpression\" && node.right.properties.length !== 0) {\n    return true;\n  }\n\n  if (node.right.type === \"ArrayExpression\" && node.right.elements.length !== 0) {\n    return true;\n  }\n\n  if (isJSXNode(node.right)) {\n    return true;\n  }\n\n  return false;\n} // For binary expressions to be consistent, we need to group\n// subsequent operators with the same precedence level under a single\n// group. Otherwise they will be nested such that some of them break\n// onto new lines but not all. Operators with the same precedence\n// level should either all break or not. Because we group them by\n// precedence level and the AST is structured based on precedence\n// level, things are naturally broken up correctly, i.e. `&&` is\n// broken before `+`.\n\n\nfunction printBinaryishExpressions(path, print, options, isNested, isInsideParenthesis) {\n  var parts = [];\n  var node = path.getValue(); // We treat BinaryExpression and LogicalExpression nodes the same.\n\n  if (isBinaryish(node)) {\n    // Put all operators with the same precedence level in the same\n    // group. The reason we only need to do this with the `left`\n    // expression is because given an expression like `1 + 2 - 3`, it\n    // is always parsed like `((1 + 2) - 3)`, meaning the `left` side\n    // is where the rest of the expression will exist. Binary\n    // expressions on the right side mean they have a difference\n    // precedence level and should be treated as a separate group, so\n    // print them normally. (This doesn't hold for the `**` operator,\n    // which is unique in that it is right-associative.)\n    if (shouldFlatten(node.operator, node.left.operator)) {\n      // Flatten them out by recursively calling this function.\n      parts = parts.concat(path.call(function (left) {\n        return printBinaryishExpressions(left, print, options,\n        /* isNested */\n        true, isInsideParenthesis);\n      }, \"left\"));\n    } else {\n      parts.push(path.call(print, \"left\"));\n    }\n\n    var shouldInline = shouldInlineLogicalExpression(node);\n    var lineBeforeOperator = (node.operator === \"|>\" || node.type === \"NGPipeExpression\" || node.operator === \"|\" && options.parser === \"__vue_expression\") && !hasLeadingOwnLineComment(options.originalText, node.right, options);\n    var operator = node.type === \"NGPipeExpression\" ? \"|\" : node.operator;\n    var rightSuffix = node.type === \"NGPipeExpression\" && node.arguments.length !== 0 ? group(indent(concat([softline, \": \", join(concat([softline, \":\", ifBreak(\" \")]), path.map(print, \"arguments\").map(function (arg) {\n      return align(2, group(arg));\n    }))]))) : \"\";\n    var right = shouldInline ? concat([operator, \" \", path.call(print, \"right\"), rightSuffix]) : concat([lineBeforeOperator ? softline : \"\", operator, lineBeforeOperator ? \" \" : line, path.call(print, \"right\"), rightSuffix]); // If there's only a single binary expression, we want to create a group\n    // in order to avoid having a small right part like -1 be on its own line.\n\n    var parent = path.getParentNode();\n    var shouldGroup = !(isInsideParenthesis && node.type === \"LogicalExpression\") && parent.type !== node.type && node.left.type !== node.type && node.right.type !== node.type;\n    parts.push(\" \", shouldGroup ? group(right) : right); // The root comments are already printed, but we need to manually print\n    // the other ones since we don't call the normal print on BinaryExpression,\n    // only for the left and right parts\n\n    if (isNested && node.comments) {\n      parts = comments.printComments(path, function () {\n        return concat(parts);\n      }, options);\n    }\n  } else {\n    // Our stopping case. Simply print the node normally.\n    parts.push(path.call(print));\n  }\n\n  return parts;\n}\n\nfunction printAssignmentRight(leftNode, rightNode, printedRight, options) {\n  if (hasLeadingOwnLineComment(options.originalText, rightNode, options)) {\n    return indent(concat([hardline, printedRight]));\n  }\n\n  var canBreak = isBinaryish(rightNode) && !shouldInlineLogicalExpression(rightNode) || rightNode.type === \"ConditionalExpression\" && isBinaryish(rightNode.test) && !shouldInlineLogicalExpression(rightNode.test) || rightNode.type === \"StringLiteralTypeAnnotation\" || rightNode.type === \"ClassExpression\" && rightNode.decorators && rightNode.decorators.length || (leftNode.type === \"Identifier\" || isStringLiteral(leftNode) || leftNode.type === \"MemberExpression\") && (isStringLiteral(rightNode) || isMemberExpressionChain(rightNode)) && // do not put values on a separate line from the key in json\n  options.parser !== \"json\" && options.parser !== \"json5\" || rightNode.type === \"SequenceExpression\";\n\n  if (canBreak) {\n    return group(indent(concat([line, printedRight])));\n  }\n\n  return concat([\" \", printedRight]);\n}\n\nfunction printAssignment(leftNode, printedLeft, operator, rightNode, printedRight, options) {\n  if (!rightNode) {\n    return printedLeft;\n  }\n\n  var printed = printAssignmentRight(leftNode, rightNode, printedRight, options);\n  return group(concat([printedLeft, operator, printed]));\n}\n\nfunction adjustClause(node, clause, forceSpace) {\n  if (node.type === \"EmptyStatement\") {\n    return \";\";\n  }\n\n  if (node.type === \"BlockStatement\" || forceSpace) {\n    return concat([\" \", clause]);\n  }\n\n  return indent(concat([line, clause]));\n}\n\nfunction nodeStr(node, options, isFlowOrTypeScriptDirectiveLiteral) {\n  var raw = rawText(node);\n  var isDirectiveLiteral = isFlowOrTypeScriptDirectiveLiteral || node.type === \"DirectiveLiteral\";\n  return printString(raw, options, isDirectiveLiteral);\n}\n\nfunction printRegex(node) {\n  var flags = node.flags.split(\"\").sort().join(\"\");\n  return \"/\".concat(node.pattern, \"/\").concat(flags);\n}\n\nfunction isLastStatement(path) {\n  var parent = path.getParentNode();\n\n  if (!parent) {\n    return true;\n  }\n\n  var node = path.getValue();\n  var body = (parent.body || parent.consequent).filter(function (stmt) {\n    return stmt.type !== \"EmptyStatement\";\n  });\n  return body && body[body.length - 1] === node;\n}\n\nfunction hasLeadingComment(node) {\n  return node.comments && node.comments.some(function (comment) {\n    return comment.leading;\n  });\n}\n\nfunction hasTrailingComment(node) {\n  return node.comments && node.comments.some(function (comment) {\n    return comment.trailing;\n  });\n}\n\nfunction hasLeadingOwnLineComment(text, node, options) {\n  if (isJSXNode(node)) {\n    return hasNodeIgnoreComment(node);\n  }\n\n  var res = node.comments && node.comments.some(function (comment) {\n    return comment.leading && hasNewline(text, options.locEnd(comment));\n  });\n  return res;\n}\n\nfunction isFlowAnnotationComment(text, typeAnnotation, options) {\n  var start = options.locStart(typeAnnotation);\n  var end = skipWhitespace(text, options.locEnd(typeAnnotation));\n  return text.substr(start, 2) === \"/*\" && text.substr(end, 2) === \"*/\";\n}\n\nfunction exprNeedsASIProtection(path, options) {\n  var node = path.getValue();\n  var maybeASIProblem = pathNeedsParens(path, options) || node.type === \"ParenthesizedExpression\" || node.type === \"TypeCastExpression\" || node.type === \"ArrowFunctionExpression\" && !shouldPrintParamsWithoutParens(path, options) || node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\" || node.type === \"UnaryExpression\" && node.prefix && (node.operator === \"+\" || node.operator === \"-\") || node.type === \"TemplateLiteral\" || node.type === \"TemplateElement\" || isJSXNode(node) || node.type === \"BindExpression\" && !node.object || node.type === \"RegExpLiteral\" || node.type === \"Literal\" && node.pattern || node.type === \"Literal\" && node.regex;\n\n  if (maybeASIProblem) {\n    return true;\n  }\n\n  if (!hasNakedLeftSide(node)) {\n    return false;\n  }\n\n  return path.call.apply(path, [function (childPath) {\n    return exprNeedsASIProtection(childPath, options);\n  }].concat(getLeftSidePathName(path, node)));\n}\n\nfunction stmtNeedsASIProtection(path, options) {\n  var node = path.getNode();\n\n  if (node.type !== \"ExpressionStatement\") {\n    return false;\n  }\n\n  return path.call(function (childPath) {\n    return exprNeedsASIProtection(childPath, options);\n  }, \"expression\");\n}\n\nfunction classPropMayCauseASIProblems(path) {\n  var node = path.getNode();\n\n  if (node.type !== \"ClassProperty\") {\n    return false;\n  }\n\n  var name = node.key && node.key.name; // this isn't actually possible yet with most parsers available today\n  // so isn't properly tested yet.\n\n  if ((name === \"static\" || name === \"get\" || name === \"set\") && !node.value && !node.typeAnnotation) {\n    return true;\n  }\n}\n\nfunction classChildNeedsASIProtection(node) {\n  if (!node) {\n    return;\n  }\n\n  if (node[\"static\"] || node.accessibility // TypeScript\n  ) {\n      return false;\n    }\n\n  if (!node.computed) {\n    var name = node.key && node.key.name;\n\n    if (name === \"in\" || name === \"instanceof\") {\n      return true;\n    }\n  }\n\n  switch (node.type) {\n    case \"ClassProperty\":\n    case \"TSAbstractClassProperty\":\n      return node.computed;\n\n    case \"MethodDefinition\": // Flow\n\n    case \"TSAbstractMethodDefinition\": // TypeScript\n\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      {\n        // Babel\n        var isAsync = node.value ? node.value.async : node.async;\n        var isGenerator = node.value ? node.value.generator : node.generator;\n\n        if (isAsync || node.kind === \"get\" || node.kind === \"set\") {\n          return false;\n        }\n\n        if (node.computed || isGenerator) {\n          return true;\n        }\n\n        return false;\n      }\n\n    default:\n      /* istanbul ignore next */\n      return false;\n  }\n} // This recurses the return argument, looking for the first token\n// (the leftmost leaf node) and, if it (or its parents) has any\n// leadingComments, returns true (so it can be wrapped in parens).\n\n\nfunction returnArgumentHasLeadingComment(options, argument) {\n  if (hasLeadingOwnLineComment(options.originalText, argument, options)) {\n    return true;\n  }\n\n  if (hasNakedLeftSide(argument)) {\n    var leftMost = argument;\n    var newLeftMost;\n\n    while (newLeftMost = getLeftSide(leftMost)) {\n      leftMost = newLeftMost;\n\n      if (hasLeadingOwnLineComment(options.originalText, leftMost, options)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction isMemberExpressionChain(node) {\n  if (node.type !== \"MemberExpression\" && node.type !== \"OptionalMemberExpression\") {\n    return false;\n  }\n\n  if (node.object.type === \"Identifier\") {\n    return true;\n  }\n\n  return isMemberExpressionChain(node.object);\n} // Hack to differentiate between the following two which have the same ast\n// type T = { method: () => void };\n// type T = { method(): void };\n\n\nfunction isObjectTypePropertyAFunction(node, options) {\n  return (node.type === \"ObjectTypeProperty\" || node.type === \"ObjectTypeInternalSlot\") && node.value.type === \"FunctionTypeAnnotation\" && !node[\"static\"] && !isFunctionNotation(node, options);\n} // TODO: This is a bad hack and we need a better way to distinguish between\n// arrow functions and otherwise\n\n\nfunction isFunctionNotation(node, options) {\n  return isGetterOrSetter(node) || sameLocStart(node, node.value, options);\n}\n\nfunction isGetterOrSetter(node) {\n  return node.kind === \"get\" || node.kind === \"set\";\n}\n\nfunction sameLocStart(nodeA, nodeB, options) {\n  return options.locStart(nodeA) === options.locStart(nodeB);\n} // Hack to differentiate between the following two which have the same ast\n// declare function f(a): void;\n// var f: (a) => void;\n\n\nfunction isTypeAnnotationAFunction(node, options) {\n  return (node.type === \"TypeAnnotation\" || node.type === \"TSTypeAnnotation\") && node.typeAnnotation.type === \"FunctionTypeAnnotation\" && !node[\"static\"] && !sameLocStart(node, node.typeAnnotation, options);\n}\n\nfunction isNodeStartingWithDeclare(node, options) {\n  if (!(options.parser === \"flow\" || options.parser === \"typescript\")) {\n    return false;\n  }\n\n  return options.originalText.slice(0, options.locStart(node)).match(/declare[ \\t]*$/) || options.originalText.slice(node.range[0], node.range[1]).startsWith(\"declare \");\n}\n\nfunction shouldHugType(node) {\n  if (isSimpleFlowType(node) || isObjectType(node)) {\n    return true;\n  }\n\n  if (node.type === \"UnionTypeAnnotation\" || node.type === \"TSUnionType\") {\n    var voidCount = node.types.filter(function (n) {\n      return n.type === \"VoidTypeAnnotation\" || n.type === \"TSVoidKeyword\" || n.type === \"NullLiteralTypeAnnotation\" || n.type === \"TSNullKeyword\";\n    }).length;\n    var objectCount = node.types.filter(function (n) {\n      return n.type === \"ObjectTypeAnnotation\" || n.type === \"TSTypeLiteral\" || // This is a bit aggressive but captures Array<{x}>\n      n.type === \"GenericTypeAnnotation\" || n.type === \"TSTypeReference\";\n    }).length;\n\n    if (node.types.length - 1 === voidCount && objectCount > 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction shouldHugArguments(fun) {\n  return fun && fun.params && fun.params.length === 1 && !fun.params[0].comments && (fun.params[0].type === \"ObjectPattern\" || fun.params[0].type === \"ArrayPattern\" || fun.params[0].type === \"Identifier\" && fun.params[0].typeAnnotation && (fun.params[0].typeAnnotation.type === \"TypeAnnotation\" || fun.params[0].typeAnnotation.type === \"TSTypeAnnotation\") && isObjectType(fun.params[0].typeAnnotation.typeAnnotation) || fun.params[0].type === \"FunctionTypeParam\" && isObjectType(fun.params[0].typeAnnotation) || fun.params[0].type === \"AssignmentPattern\" && (fun.params[0].left.type === \"ObjectPattern\" || fun.params[0].left.type === \"ArrayPattern\") && (fun.params[0].right.type === \"Identifier\" || fun.params[0].right.type === \"ObjectExpression\" && fun.params[0].right.properties.length === 0 || fun.params[0].right.type === \"ArrayExpression\" && fun.params[0].right.elements.length === 0)) && !fun.rest;\n}\n\nfunction templateLiteralHasNewLines(template) {\n  return template.quasis.some(function (quasi) {\n    return quasi.value.raw.includes(\"\\n\");\n  });\n}\n\nfunction isTemplateOnItsOwnLine(n, text, options) {\n  return (n.type === \"TemplateLiteral\" && templateLiteralHasNewLines(n) || n.type === \"TaggedTemplateExpression\" && templateLiteralHasNewLines(n.quasi)) && !hasNewline(text, options.locStart(n), {\n    backwards: true\n  });\n}\n\nfunction printArrayItems(path, options, printPath, print) {\n  var printedElements = [];\n  var separatorParts = [];\n  path.each(function (childPath) {\n    printedElements.push(concat(separatorParts));\n    printedElements.push(group(print(childPath)));\n    separatorParts = [\",\", line];\n\n    if (childPath.getValue() && isNextLineEmpty(options.originalText, childPath.getValue(), options)) {\n      separatorParts.push(softline);\n    }\n  }, printPath);\n  return concat(printedElements);\n}\n\nfunction hasDanglingComments(node) {\n  return node.comments && node.comments.some(function (comment) {\n    return !comment.leading && !comment.trailing;\n  });\n}\n\nfunction needsHardlineAfterDanglingComment(node) {\n  if (!node.comments) {\n    return false;\n  }\n\n  var lastDanglingComment = getLast(node.comments.filter(function (comment) {\n    return !comment.leading && !comment.trailing;\n  }));\n  return lastDanglingComment && !handleComments.isBlockComment(lastDanglingComment);\n}\n\nfunction isLiteral(node) {\n  return node.type === \"BooleanLiteral\" || node.type === \"DirectiveLiteral\" || node.type === \"Literal\" || node.type === \"NullLiteral\" || node.type === \"NumericLiteral\" || node.type === \"RegExpLiteral\" || node.type === \"StringLiteral\" || node.type === \"TemplateLiteral\" || node.type === \"TSTypeLiteral\" || node.type === \"JSXText\";\n}\n\nfunction isStringPropSafeToCoerceToIdentifier(node, options) {\n  return isStringLiteral(node.key) && isIdentifierName(node.key.value) && options.parser !== \"json\" && !(options.parser === \"typescript\" && node.type === \"ClassProperty\");\n}\n\nfunction isNumericLiteral(node) {\n  return node.type === \"NumericLiteral\" || node.type === \"Literal\" && typeof node.value === \"number\";\n}\n\nfunction isStringLiteral(node) {\n  return node.type === \"StringLiteral\" || node.type === \"Literal\" && typeof node.value === \"string\";\n}\n\nfunction isObjectType(n) {\n  return n.type === \"ObjectTypeAnnotation\" || n.type === \"TSTypeLiteral\";\n}\n\nvar unitTestRe = /^(skip|[fx]?(it|describe|test))$/; // eg; `describe(\"some string\", (done) => {})`\n\nfunction isTestCall(n, parent) {\n  if (n.type !== \"CallExpression\") {\n    return false;\n  }\n\n  if (n.arguments.length === 1) {\n    if (isAngularTestWrapper(n) && parent && isTestCall(parent)) {\n      return isFunctionOrArrowExpression(n.arguments[0]);\n    }\n\n    if (isUnitTestSetUp(n)) {\n      return isAngularTestWrapper(n.arguments[0]);\n    }\n  } else if (n.arguments.length === 2 || n.arguments.length === 3) {\n    if ((n.callee.type === \"Identifier\" && unitTestRe.test(n.callee.name) || isSkipOrOnlyBlock(n)) && (isTemplateLiteral(n.arguments[0]) || isStringLiteral(n.arguments[0]))) {\n      // it(\"name\", () => { ... }, 2500)\n      if (n.arguments[2] && !isNumericLiteral(n.arguments[2])) {\n        return false;\n      }\n\n      return (n.arguments.length === 2 ? isFunctionOrArrowExpression(n.arguments[1]) : isFunctionOrArrowExpressionWithBody(n.arguments[1]) && n.arguments[1].params.length <= 1) || isAngularTestWrapper(n.arguments[1]);\n    }\n  }\n\n  return false;\n}\n\nfunction isSkipOrOnlyBlock(node) {\n  return (node.callee.type === \"MemberExpression\" || node.callee.type === \"OptionalMemberExpression\") && node.callee.object.type === \"Identifier\" && node.callee.property.type === \"Identifier\" && unitTestRe.test(node.callee.object.name) && (node.callee.property.name === \"only\" || node.callee.property.name === \"skip\");\n}\n\nfunction isTemplateLiteral(node) {\n  return node.type === \"TemplateLiteral\";\n} // `inject` is used in AngularJS 1.x, `async` in Angular 2+\n// example: https://docs.angularjs.org/guide/unit-testing#using-beforeall-\n\n\nfunction isAngularTestWrapper(node) {\n  return (node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\") && node.callee.type === \"Identifier\" && (node.callee.name === \"async\" || node.callee.name === \"inject\" || node.callee.name === \"fakeAsync\");\n}\n\nfunction isFunctionOrArrowExpression(node) {\n  return node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\";\n}\n\nfunction isFunctionOrArrowExpressionWithBody(node) {\n  return node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\" && node.body.type === \"BlockStatement\";\n}\n\nfunction isUnitTestSetUp(n) {\n  var unitTestSetUpRe = /^(before|after)(Each|All)$/;\n  return n.callee.type === \"Identifier\" && unitTestSetUpRe.test(n.callee.name) && n.arguments.length === 1;\n}\n\nfunction isTheOnlyJSXElementInMarkdown(options, path) {\n  if (options.parentParser !== \"markdown\" && options.parentParser !== \"mdx\") {\n    return false;\n  }\n\n  var node = path.getNode();\n\n  if (!node.expression || !isJSXNode(node.expression)) {\n    return false;\n  }\n\n  var parent = path.getParentNode();\n  return parent.type === \"Program\" && parent.body.length == 1;\n}\n\nfunction willPrintOwnComments(path\n/*, options */\n) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  return (node && (isJSXNode(node) || hasFlowShorthandAnnotationComment(node) || parent && parent.type === \"CallExpression\" && (hasFlowAnnotationComment(node.leadingComments) || hasFlowAnnotationComment(node.trailingComments))) || parent && (parent.type === \"JSXSpreadAttribute\" || parent.type === \"JSXSpreadChild\" || parent.type === \"UnionTypeAnnotation\" || parent.type === \"TSUnionType\" || (parent.type === \"ClassDeclaration\" || parent.type === \"ClassExpression\") && parent.superClass === node)) && !hasIgnoreComment(path);\n}\n\nfunction canAttachComment(node) {\n  return node.type && node.type !== \"CommentBlock\" && node.type !== \"CommentLine\" && node.type !== \"Line\" && node.type !== \"Block\" && node.type !== \"EmptyStatement\" && node.type !== \"TemplateElement\" && node.type !== \"Import\";\n}\n\nfunction printComment(commentPath, options) {\n  var comment = commentPath.getValue();\n\n  switch (comment.type) {\n    case \"CommentBlock\":\n    case \"Block\":\n      {\n        if (isIndentableBlockComment(comment)) {\n          var printed = printIndentableBlockComment(comment); // We need to prevent an edge case of a previous trailing comment\n          // printed as a `lineSuffix` which causes the comments to be\n          // interleaved. See https://github.com/prettier/prettier/issues/4412\n\n          if (comment.trailing && !hasNewline(options.originalText, options.locStart(comment), {\n            backwards: true\n          })) {\n            return concat([hardline, printed]);\n          }\n\n          return printed;\n        }\n\n        var isInsideFlowComment = options.originalText.substr(options.locEnd(comment) - 3, 3) === \"*-/\";\n        return \"/*\" + comment.value + (isInsideFlowComment ? \"*-/\" : \"*/\");\n      }\n\n    case \"CommentLine\":\n    case \"Line\":\n      // Print shebangs with the proper comment characters\n      if (options.originalText.slice(options.locStart(comment)).startsWith(\"#!\")) {\n        return \"#!\" + comment.value.trimRight();\n      }\n\n      return \"//\" + comment.value.trimRight();\n\n    default:\n      throw new Error(\"Not a comment: \" + JSON.stringify(comment));\n  }\n}\n\nfunction isIndentableBlockComment(comment) {\n  // If the comment has multiple lines and every line starts with a star\n  // we can fix the indentation of each line. The stars in the `/*` and\n  // `*/` delimiters are not included in the comment value, so add them\n  // back first.\n  var lines = \"*\".concat(comment.value, \"*\").split(\"\\n\");\n  return lines.length > 1 && lines.every(function (line) {\n    return line.trim()[0] === \"*\";\n  });\n}\n\nfunction printIndentableBlockComment(comment) {\n  var lines = comment.value.split(\"\\n\");\n  return concat([\"/*\", join(hardline, lines.map(function (line, index) {\n    return index === 0 ? line.trimRight() : \" \" + (index < lines.length - 1 ? line.trim() : line.trimLeft());\n  })), \"*/\"]);\n}\n\nfunction rawText(node) {\n  // our artifically created AST doesn't have extra property\n  //return node.extra ? node.extra.raw : node.raw;\n  return node.value;\n}\n\nfunction identity(x) {\n  return x;\n}\n\nmodule.exports = {\n  preprocess: preprocess,\n  print: genericPrint,\n  embed: embed,\n  insertPragma: insertPragma,\n  massageAstNode: clean,\n  hasPrettierIgnore: hasPrettierIgnore,\n  willPrintOwnComments: willPrintOwnComments,\n  canAttachComment: canAttachComment,\n  printComment: printComment,\n  isBlockComment: handleComments.isBlockComment,\n  handleComments: {\n    ownLine: handleComments.handleOwnLineComment,\n    endOfLine: handleComments.handleEndOfLineComment,\n    remaining: handleComments.handleRemainingComment\n  }\n};"],"sourceRoot":""}
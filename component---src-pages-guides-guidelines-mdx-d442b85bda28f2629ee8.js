(self.webpackChunknulogy_design=self.webpackChunknulogy_design||[]).push([[5609],{40273:function(e,t,n){"use strict";n.r(t),n.d(t,{_frontmatter:function(){return i},default:function(){return m}});var o=n(12265),a=(n(67294),n(64983)),s=n(97933),i={},r={_frontmatter:i},l=s.Z;function m(e){var t=e.components,n=(0,o.Z)(e,["components"]);return(0,a.kt)(l,Object.assign({},r,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",null,"NDS Guidelines"),(0,a.kt)("h2",null,"1. Always use the theme"),(0,a.kt)("p",null,"The ",(0,a.kt)("a",Object.assign({parentName:"p"},{href:"/theme"}),"theme")," should include all the style values you need to build your application and implement custom components."),(0,a.kt)("p",null,"When using style props on an NDS component, you can use the theme keys directly:"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),'const FormLabel = ({children}}) => (\n    <Text fontSize="small">{children}:</Text>)\n')),(0,a.kt)("p",null,"If using styled-components, you can access the theme like so:"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const FormLabel  = styled(Text)(({theme}) => ({\n        fontSize: theme.fontSizes.small,\n})\n")),(0,a.kt)("p",null,"Wrapping your application in the ",(0,a.kt)("a",Object.assign({parentName:"p"},{href:"https://github.com/nulogy/design-system#2-wrap-your-appliction-in-our-theme-provider"}),"NDSProvider")," component provides the theme to all NDS components inside of it. Never import the theme directly from @nulogy/components as this will disconnect your component from the Provider."),(0,a.kt)("p",null,"If a value that isn't included in the theme is needed, e.g a margin of ",(0,a.kt)("inlineCode",{parentName:"p"},"18px")," instead of ",(0,a.kt)("inlineCode",{parentName:"p"},"16px"),". consider if these are ",(0,a.kt)("a",Object.assign({parentName:"p"},{href:"https://css-tricks.com/magic-numbers-in-css/"}),"magic numbers")," that are trying to point you towards a rework of your layout. Feel free to reach out for a consult from Design Ops if needed."),(0,a.kt)("p",null,"If you're absolutely sure a custom value is needed, make sure to store it in a constant so it can be found later and the context can remain, e:g:"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),'const LIGHTEST_ACCESSIBLE_TEXT = "#949494";\nconst FormLabel = ({children}}) => (\n    <Text color={LIGHTEST_ACCESSIBLE_TEXT}>{children}:</Text>)\n')),(0,a.kt)("h2",null,"2. Use existing components and props first"),(0,a.kt)("p",null,"Look for props and primitive components that can be used together to implement specific behaviours in your app. Remember that you can use a number of style props to change the look of NDS components: instead of divs, ps, or other html tags, you could be using ",(0,a.kt)("a",Object.assign({parentName:"p"},{href:"/components/box/"}),"Box"),", ",(0,a.kt)("a",Object.assign({parentName:"p"},{href:"/components/Flex"}),"Flex")," and ",(0,a.kt)("a",Object.assign({parentName:"p"},{href:"/components/Text"}),"Text"),". This gives us more control and allows first-class access to the theme."),(0,a.kt)("p",null,"For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),'const FormLabel = styled("p")({\n  fontSize: "12px",\n  textTransform: "uppercase",\n  textAlign: "right",\n});\n')),(0,a.kt)("p",null,"None of this is necessary custom code as ",(0,a.kt)("inlineCode",{parentName:"p"},"Text")," already supports changing the ",(0,a.kt)("inlineCode",{parentName:"p"},"fontSize"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"textTransform")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"textAlign.")),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),'const FormLabel = ({children}}) => (\n    <Text fontSize="small" textTransform="uppercase" textAlign="right">{children}:</Text>)\n')),(0,a.kt)("p",null,"This should be faster to write, more readable and searchable, and guarantees a connection to the theme."),(0,a.kt)("h2",null,"3. Name components after what they do"),(0,a.kt)("p",null,"Name components after what they do, not how they do it. Often we're tempted to name an internal components Styled","_","_","_","_"," (e.g ",(0,a.kt)("inlineCode",{parentName:"p"},"StyledText"),") just for the purpose of making some style changes, but this can make it tricky to understand what that component was meant to do and to make markup changes later on."),(0,a.kt)("p",null,"Instead of something generic like ",(0,a.kt)("inlineCode",{parentName:"p"},"StyledText"),", try a contextual name: e.g, if the component has a specific purpose like displaying capacity values, try something like like ",(0,a.kt)("inlineCode",{parentName:"p"},"CapacityText"),". Or if it's meant to be used as a Label for another value, try ",(0,a.kt)("inlineCode",{parentName:"p"},"CapacityLabel"),"."),(0,a.kt)("h2",null,"4. Minimize component props"),(0,a.kt)("p",null,"Too many props can make the component difficult to understand. It can be hard to see what props are needed where, making it hard to reuse in the future, accomodate changes and even to test."),(0,a.kt)("p",null,"Try to keep the number of your component props to a minimum. If your component has a large number of unrelated props, it can be a sign that it should be broken down into multiple meaningful components instead."),(0,a.kt)("p",null,"Feel free to reach out to Design Ops for a consult on component design at any time if you're unsure of how something should be getting broken down."),(0,a.kt)("h2",null,"5. Favour composition"),(0,a.kt)("p",null,"Rather than having large monolithic components with many properties, try composing multiple simple components together instead. This will make it easier to make changes later without forgetting the original context of a design. See the ",(0,a.kt)("a",Object.assign({parentName:"p"},{href:"https://reactjs.org/docs/composition-vs-inheritance.html"}),"React introduction")," for more information."),(0,a.kt)("p",null,"There are some simple ways to ensure components are being composed:"),(0,a.kt)("h3",null,"Build small simple components first"),(0,a.kt)("p",null,"Instead of building out a whole feature at once, start by building small components for each thing you need to do and then combine them together."),(0,a.kt)("p",null,"Here is an example of a component built up of multiple simple components. We want to display a comment in a Card layout, and allow the user to Edit and Remove it:"),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),'/// Comment.jsx\n\nconst Card = ({ children }) => (\n  <Box boxShadow="medium" backgroundColor="white">\n    {children}\n  </Box>\n);\nconst Title = ({ children }) => (\n  <Heading2 color="darkBlue">{children}</Heading2>\n);\nconst EditButton = ({ onClick }) => (\n  <Button onClick={onClick}>{t("Edit")}</Button>\n);\nconst RemoveButton = ({ onClick }) => (\n  <Button onClick={onClick}>{t("Remove")}</Button>\n);\n\nconst Comment = ({ title, children, isRemoveable }) => (\n  <Card>\n    <Title>{title}</Title>\n    <Box>{children}</Box>\n    <EditButton />\n    {isRemoveable && <RemoveButton />}\n  </Card>\n);\n')),(0,a.kt)("h3",null,"Separate stateful and stateless components"),(0,a.kt)("p",null,"State should come from the outermost parent component of a set of related components and the inner components can all be stateless and simply take in the state of the parent through props."),(0,a.kt)("p",null,"This makes it simple to seperate presentational logic (i.e. this is what the component looks like) vs application logic (how to component behaves in the app and and relates to its data)."),(0,a.kt)("p",null,"Using the presentational comment card, we can wrap it in a stateful ",(0,a.kt)("inlineCode",{parentName:"p"},"UserCommentsContainer")," component that deals with fetching and determining which comments to display."),(0,a.kt)("pre",null,(0,a.kt)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"///  UserCommentsContainer .jsx\n\nconst  UserCommentsContainer = ({currentUser}) => {\n  const [ comments, setComments] = useState();\n\n  useEffect(() => {\n    // fetch the comments from somewhere, and use only the current users comments.\n    const usersComments = fetch(getComments).filter(({user} => user === currentUser);\n    setComments(usersComments);\n  })\n\n  return <Box>\n      <Heading1>{currentUser}'s Comments</Heading1>\n      {comments.map(({title, body} ) => <Comment title={title}>{body}<Comment>)}\n    </Box>\n}\n")),(0,a.kt)("p",null,"This way we can use the Comment component wherever we need to display a comment without being tied to specific data or page-level requirements."),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Pull requests on these guidelines are always welcome at ",(0,a.kt)("a",Object.assign({parentName:"em"},{href:"https://github.com/nulogy/nulogy.design"}),"github.com/nulogy/nulogy.design"),".")))}m.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-guides-guidelines-mdx-d442b85bda28f2629ee8.js.map